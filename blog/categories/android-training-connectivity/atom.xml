<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android:Training:Connectivity | 四方城]]></title>
  <link href="http://kesenhoo.github.com/blog/categories/android-training-connectivity/atom.xml" rel="self"/>
  <link href="http://kesenhoo.github.com/"/>
  <updated>2013-08-27T22:37:39+08:00</updated>
  <id>http://kesenhoo.github.com/</id>
  <author>
    <name><![CDATA[Kesen Hoo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android Training Connectivity - 执行网络操作(Lesson 3 - 解析XML数据)]]></title>
    <link href="http://kesenhoo.github.com/blog/2012/05/07/android-training-connectivity-network-operations-lesson-3/"/>
    <updated>2012-05-07T17:05:00+08:00</updated>
    <id>http://kesenhoo.github.com/blog/2012/05/07/android-training-connectivity-network-operations-lesson-3</id>
    <content type="html"><![CDATA[<p><strong>第3课:Parsing XML Data</strong>
Extensible Markup Language (XML) .很多网站或博客上都提供XML feed来记录更新的信息，以便用户进行订阅读取。</p>

<p>那么上传[?]与解析XML数据就成了app的一个常见的功能。 这一课会介绍如何解析XML文档并使用他们的数据。</p>

<p><em>([?]这里很奇怪，为什么是Upload，看文章最后一段代码示例的注释，应该是Download才对)</em></p>

<h2>Choose a Parser(选择一个解析器)</h2>

<p>我们推荐<a href="http://developer.android.com/reference/org/xmlpull/v1/XmlPullParser.html">XmlPullParser</a>, 它是在Android上一个高效且可维护的解析XML方法。 Android 上有这个接口的两种实现方式：</p>

<ul>
<li><a href="http://kxml.sourceforge.net/">KXmlParser</a> via <a href="http://developer.android.com/reference/org/xmlpull/v1/XmlPullParserFactory.html#newPullParser(">XmlPullParserFactory.newPullParser()</a>).</li>
<li>ExpatPullParser, via <a href="http://developer.android.com/reference/android/util/Xml.html#newPullParser(">Xml.newPullParser()</a>).</li>
</ul>


<p>两个选择都是比较好的。下面的示例中是使用ExpatPullParser, via Xml.newPullParser().</p>

<!-- more -->


<h2>Analyze the Feed(分析Feed)</h2>

<p>解析一个feed的第一步是决定需要获取哪些字段。这样解析器才去抽取出那些需要的字段而忽视剩下的。
下面一段章节概览Sample app中截取的一段代码示例.
```xml
&lt;?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:creativeCommons="http://backend.userland.com/creativeCommonsRssModule" ...">
<title type="text">newest questions tagged android - Stack Overflow</title>
...</p>

<pre><code>&lt;entry&gt;
...
&lt;/entry&gt;
&lt;entry&gt;
    &lt;id&gt;http://stackoverflow.com/q/9439999&lt;/id&gt;
    &lt;re:rank scheme="http://stackoverflow.com"&gt;0&lt;/re:rank&gt;
    &lt;title type="text"&gt;Where is my data file?&lt;/title&gt;
    &lt;category scheme="http://stackoverflow.com/feeds/tag?tagnames=android&amp;sort=newest/tags" term="android"/&gt;
    &lt;category scheme="http://stackoverflow.com/feeds/tag?tagnames=android&amp;sort=newest/tags" term="file"/&gt;
    &lt;author&gt;
        &lt;name&gt;cliff2310&lt;/name&gt;
        &lt;uri&gt;http://stackoverflow.com/users/1128925&lt;/uri&gt;
    &lt;/author&gt;
    &lt;link rel="alternate" href="http://stackoverflow.com/questions/9439999/where-is-my-data-file" /&gt;
    &lt;published&gt;2012-02-25T00:30:54Z&lt;/published&gt;
    &lt;updated&gt;2012-02-25T00:30:54Z&lt;/updated&gt;
    &lt;summary type="html"&gt;
        &lt;p&gt;I have an Application that requires a data file...&lt;/p&gt;

    &lt;/summary&gt;
&lt;/entry&gt;
&lt;entry&gt;
...
&lt;/entry&gt;
</code></pre>

<p>...
</feed>
```
在sample app中抽取了entry 标签与它的子标签 title, link,summary.</p>

<h2>Instantiate the Parser(实例化解析器)</h2>

<p>下一步就是实例化一个parser并开始解析的操作。请看下面的示例：
```java
public class StackOverflowXmlParser {</p>

<pre><code>// We don't use namespaces
private static final String ns = null;

public List parse(InputStream in) throws XmlPullParserException, IOException {
    try {
        XmlPullParser parser = Xml.newPullParser();
        parser.setFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES, false);
        parser.setInput(in, null);
        parser.nextTag();
        return readFeed(parser);
    } finally {
        in.close();
    }
}
</code></pre>

<p> ...
}
```</p>

<h2>Read the Feed(读取Feed)</h2>

<p>The readFeed() 实际上并没有处理feed的内容。它只是在寻找一个 "entry" 的标签作为递归（recursively）处理整个feed的起点。如果一个标签它不是"entry", readFeed()方法会跳过它. 当整个feed都被递归处理后，readFeed() 会返回一个包含了entry标签（包括里面的数据成员）的 List 。</p>

<p>```java
private List readFeed(XmlPullParser parser) throws XmlPullParserException, IOException {</p>

<pre><code>List entries = new ArrayList();

parser.require(XmlPullParser.START_TAG, ns, "feed");
while (parser.next() != XmlPullParser.END_TAG) {
    if (parser.getEventType() != XmlPullParser.START_TAG) {
        continue;
    }
    String name = parser.getName();
    // Starts by looking for the entry tag
    if (name.equals("entry")) {
        entries.add(readEntry(parser));
    } else {
        skip(parser);
    }
}
return entries;
</code></pre>

<p>}
```</p>

<h2>Parse XML(解析XML)</h2>

<p>解析步骤如下：</p>

<ul>
<li>正如在上面“ 分析Feed”所说的, 判断出你想要的tag。这个example抽取了 entry 标签与它的内部标签 title, link,summary.</li>
<li>创建下面的方法:

<ul>
<li>为每一个你想要获取的标签创建一个 "read" 方法。例如 readEntry(), readTitle() 等等. 解析器从input stream中读取tag . 当读取到 entry, title, link 或者 summary 标签时，它会为那些标签调用相应的方法，否则，跳过这个标签。</li>
<li>为每一个不同的标签的提取数据方法进行优化，例如：

<ul>
<li>对于 title and summary tags, 解析器调用 readText(). 通过调用parser.getText().来获取返回数据。</li>
<li>对于 link tag,解析器先判断这个link是否是我们想要的类型，然后再读取数据。可以使用 parser.getAttributeValue() 来获取返回数据。</li>
<li>对于 entry tag, 解析起调用 readEntry(). 这个方法解析entry的内部标签并返回一个带有title, link, and summary数据成员的Entry对象。</li>
</ul>
</li>
<li>一个帮助方法： skip() . 关于这部分的讨论，请看下面一部分内容：Skip Tags You Don't Care About</li>
</ul>
</li>
</ul>


<p>下面的代码演示了如何解析 entries, titles, links, 与 summaries.
```java
public static class Entry {</p>

<pre><code>public final String title;
public final String link;
public final String summary;

private Entry(String title, String summary, String link) {
    this.title = title;
    this.summary = summary;
    this.link = link;
}
</code></pre>

<p>}</p>

<p>// Parses the contents of an entry. If it encounters a title, summary, or link tag, hands them off
// to their respective "read" methods for processing. Otherwise, skips the tag.
private Entry readEntry(XmlPullParser parser) throws XmlPullParserException, IOException {</p>

<pre><code>parser.require(XmlPullParser.START_TAG, ns, "entry");
String title = null;
String summary = null;
String link = null;
while (parser.next() != XmlPullParser.END_TAG) {
    if (parser.getEventType() != XmlPullParser.START_TAG) {
        continue;
    }
    String name = parser.getName();
    if (name.equals("title")) {
        title = readTitle(parser);
    } else if (name.equals("summary")) {
        summary = readSummary(parser);
    } else if (name.equals("link")) {
        link = readLink(parser);
    } else {
        skip(parser);
    }
}
return new Entry(title, summary, link);
</code></pre>

<p>}</p>

<p>// Processes title tags in the feed.
private String readTitle(XmlPullParser parser) throws IOException, XmlPullParserException {</p>

<pre><code>parser.require(XmlPullParser.START_TAG, ns, "title");
String title = readText(parser);
parser.require(XmlPullParser.END_TAG, ns, "title");
return title;
</code></pre>

<p>}</p>

<p>// Processes link tags in the feed.
private String readLink(XmlPullParser parser) throws IOException, XmlPullParserException {</p>

<pre><code>String link = "";
parser.require(XmlPullParser.START_TAG, ns, "link");
String tag = parser.getName();
String relType = parser.getAttributeValue(null, "rel");
if (tag.equals("link")) {
    if (relType.equals("alternate")){
        link = parser.getAttributeValue(null, "href");
        parser.nextTag();
    } 
}
parser.require(XmlPullParser.END_TAG, ns, "link");
return link;
</code></pre>

<p>}</p>

<p>// Processes summary tags in the feed.
private String readSummary(XmlPullParser parser) throws IOException, XmlPullParserException {</p>

<pre><code>parser.require(XmlPullParser.START_TAG, ns, "summary");
String summary = readText(parser);
parser.require(XmlPullParser.END_TAG, ns, "summary");
return summary;
</code></pre>

<p>}</p>

<p>// For the tags title and summary, extracts their text values.
private String readText(XmlPullParser parser) throws IOException, XmlPullParserException {</p>

<pre><code>String result = "";
if (parser.next() == XmlPullParser.TEXT) {
    result = parser.getText();
    parser.nextTag();
}
return result;
</code></pre>

<p>}
  ...
}
```</p>

<h2>Skip Tags You Don't Care About(跳过你不在意标签)</h2>

<p>下面演示解析器的 skip() 方法:
```java
private void skip(XmlPullParser parser) throws XmlPullParserException, IOException {</p>

<pre><code>if (parser.getEventType() != XmlPullParser.START_TAG) {
    throw new IllegalStateException();
}
int depth = 1;
while (depth != 0) {
    switch (parser.next()) {
    case XmlPullParser.END_TAG:
        depth--;
        break;
    case XmlPullParser.START_TAG:
        depth++;
        break;
    }
}
</code></pre>

<p>}
```</p>

<p>上面这个方法是如何工作的呢？</p>

<ul>
<li>It throws an exception if the current event isn't a START_TAG.</li>
<li>It consumes the START_TAG, and all events up to and including the matching END_TAG.</li>
<li>To make sure that it stops at the correct END_TAG and not at the first tag it encounters after the original START_TAG, it keeps track of the nesting depth.</li>
</ul>


<p>因此如果目前的标签有子标签, depth 的值就不会为 0，直到解析器已经处理了所有位于START_TAG与END_TAG之间的事件。例如，看解析器如何跳过 <author> 标签，它有2个子标签，<name> 与 <uri>：</p>

<ul>
<li>The first time through the while loop, the next tag the parser encounters after <author> is the START_TAG for <name>. The value for depth is incremented to 2.</li>
<li>The second time through the while loop, the next tag the parser encounters is the END_TAG </name>. The value for depth is decremented to 1.</li>
<li>The third time through the while loop, the next tag the parser encounters is the START_TAG <uri>. The value for depth is incremented to 2.</li>
<li>The fourth time through the while loop, the next tag the parser encounters is the END_TAG </uri>. The value for depth is decremented to 1.</li>
<li>The fifth time and final time through the while loop, the next tag the parser encounters is the END_TAG </author>. The value for depth is decremented to 0, indicating that the <author>element has been successfully skipped.</li>
</ul>


<h2>Consume XML Data(使用XML数据)</h2>

<p>示例程序是在 AsyncTask 中获取与解析XML数据的。当获取到数据后，程序会在main activity(NetworkActivity)里面进行更新操作。</p>

<p>在下面示例代码中，loadPage() 方法做了下面的事情：</p>

<ul>
<li>初始化一个带有URL地址的String变量，用来订阅XML feed。</li>
<li>如果用户设置与网络连接都允许，会触发 new DownloadXmlTask().execute(url). 这会初始化一个新的 DownloadXmlTask(AsyncTask subclass)  对象并且开始执行它的 execute() 方法。</li>
</ul>


<p>```java
public class NetworkActivity extends Activity {</p>

<pre><code>public static final String WIFI = "Wi-Fi";
public static final String ANY = "Any";
private static final String URL = "http://stackoverflow.com/feeds/tag?tagnames=android&amp;sort=newest";

// Whether there is a Wi-Fi connection.
private static boolean wifiConnected = false; 
// Whether there is a mobile connection.
private static boolean mobileConnected = false;
// Whether the display should be refreshed.
public static boolean refreshDisplay = true; 
public static String sPref = null;

...

// Uses AsyncTask to download the XML feed from stackoverflow.com.
public void loadPage() {  

    if((sPref.equals(ANY)) &amp;&amp; (wifiConnected || mobileConnected)) {
        new DownloadXmlTask().execute(URL);
    }
    else if ((sPref.equals(WIFI)) &amp;&amp; (wifiConnected)) {
        new DownloadXmlTask().execute(URL);
    } else {
        // show error
    }  
}
</code></pre>

<p>```</p>

<p>下面是DownloadXmlTask是怎么工作的：</p>

<p>```java
// Implementation of AsyncTask used to download XML feed from stackoverflow.com.
private class DownloadXmlTask extends AsyncTask&lt;String, Void, String> {</p>

<pre><code>@Override
protected String doInBackground(String... urls) {
    try {
        return loadXmlFromNetwork(urls[0]);
    } catch (IOException e) {
        return getResources().getString(R.string.connection_error);
    } catch (XmlPullParserException e) {
        return getResources().getString(R.string.xml_error);
    }
}

@Override
protected void onPostExecute(String result) {  
    setContentView(R.layout.main);
    // Displays the HTML string in the UI via a WebView
    WebView myWebView = (WebView) findViewById(R.id.webview);
    myWebView.loadData(result, "text/html", null);
}
</code></pre>

<p>}
```</p>

<p>下面是loadXmlFromNetwork是怎么工作的：</p>

<p>```java
// Uploads XML from stackoverflow.com, parses it, and combines it with
// HTML markup. Returns HTML string.【这里可以看出应该是Download】
private String loadXmlFromNetwork(String urlString) throws XmlPullParserException, IOException {</p>

<pre><code>InputStream stream = null;
// Instantiate the parser
StackOverflowXmlParser stackOverflowXmlParser = new StackOverflowXmlParser();
List&lt;Entry&gt; entries = null;
String title = null;
String url = null;
String summary = null;
Calendar rightNow = Calendar.getInstance(); 
DateFormat formatter = new SimpleDateFormat("MMM dd h:mmaa");

// Checks whether the user set the preference to include summary text
SharedPreferences sharedPrefs = PreferenceManager.getDefaultSharedPreferences(this);
boolean pref = sharedPrefs.getBoolean("summaryPref", false);

StringBuilder htmlString = new StringBuilder();
htmlString.append("&lt;h3&gt;" + getResources().getString(R.string.page_title) + "&lt;/h3&gt;");
htmlString.append("&lt;em&gt;" + getResources().getString(R.string.updated) + " " + 
        formatter.format(rightNow.getTime()) + "&lt;/em&gt;");

try {
    stream = downloadUrl(urlString);        
    entries = stackOverflowXmlParser.parse(stream);
// Makes sure that the InputStream is closed after the app is
// finished using it.
} finally {
    if (stream != null) {
        stream.close();
    } 
 }

// StackOverflowXmlParser returns a List (called "entries") of Entry objects.
// Each Entry object represents a single post in the XML feed.
// This section processes the entries list to combine each entry with HTML markup.
// Each entry is displayed in the UI as a link that optionally includes
// a text summary.
for (Entry entry : entries) {
    htmlString.append("&lt;p&gt;&lt;a href='");
    htmlString.append(entry.link);
    htmlString.append("'&gt;" + entry.title + "&lt;/a&gt;&lt;/p&gt;");
    // If the user set the preference to include summary text,
    // adds it to the display.
    if (pref) {
        htmlString.append(entry.summary);
    }
}
return htmlString.toString();
</code></pre>

<p>}</p>

<p>// Given a string representation of a URL, sets up a connection and gets
// an input stream.
【关于Timeout具体应该设置多少，可以借鉴这里的数据，当然前提是一般情况下】
// Given a string representation of a URL, sets up a connection and gets
// an input stream.
private InputStream downloadUrl(String urlString) throws IOException {</p>

<pre><code>URL url = new URL(urlString);
HttpURLConnection conn = (HttpURLConnection) url.openConnection();
conn.setReadTimeout(10000 /* milliseconds */);
conn.setConnectTimeout(15000 /* milliseconds */);
conn.setRequestMethod("GET");
conn.setDoInput(true);
// Starts the query
conn.connect();
return conn.getInputStream();
</code></pre>

<p>}
```</p>

<hr />

<p><strong>学习自：<a href="http://developer.android.com/training/basics/network-ops/xml.html">http://developer.android.com/training/basics/network-ops/xml.html</a>，请多指教，谢谢！</strong><br/>
<strong>转载请注明出自<a href="http://kesenhoo.github.com">http://kesenhoo.github.com</a>，谢谢配合！</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Training Connectivity - 执行网络操作(Lesson 2 - 管理网络使用方法)]]></title>
    <link href="http://kesenhoo.github.com/blog/2012/05/07/android-training-connectivity-network-operations-lesson-2/"/>
    <updated>2012-05-07T13:43:00+08:00</updated>
    <id>http://kesenhoo.github.com/blog/2012/05/07/android-training-connectivity-network-operations-lesson-2</id>
    <content type="html"><![CDATA[<p><strong>第2课:Managing Network Usage</strong></p>

<p>这一课会介绍如何细化管理使用的网络资源。如果你的程序需要执行很多网络操作，你应该提供用户设置选项来允许用户控制程序的数据偏好。例如，同步数据的频率，是否只在连接到WiFi才进行下载与上传操作，是否在漫游时使用套餐数据流量等等。这样用户才能在快到达流量上限时关闭你的程序获取数据功能。</p>

<p>关于如何编写一个最小化下载与网络操作对电量影响的程序，请参考：</p>

<p><a href="http://developer.android.com/training/monitoring-device-state/index.html">Optimizing Battery Life</a>:
<a href="http://developer.android.com/training/efficient-downloads/index.html">Transferring Data Without Draining the Battery</a>:</p>

<!-- more -->


<h2>Check a Device's Network Connection(检查设备的网络连接信息)</h2>

<p>设备可以有许多种网络连接。关于所有可能的网络连接类型，请看<a href="http://developer.android.com/reference/android/net/ConnectivityManager.html">ConnectivityManager</a>.</p>

<p>通常Wi-Fi是比较快的。移动数据通常都是需要按流量计费，会比较贵. 通常我们会选择让app在连接到WiFi时去获取大量的数据。</p>

<p>那么，我们就需要在执行网络操作之前检查当前连接的网络信息。这样可以防止你的程序不经意连接使用了非意向的网络频道。为了实现这个目的，我们需要使用到下面两个类：</p>

<ul>
<li><a href="http://developer.android.com/reference/android/net/ConnectivityManager.html">ConnectivityManager</a>: Answers queries about the state of network connectivity. It also notifies applications when network connectivity changes.</li>
<li><a href="http://developer.android.com/reference/android/net/NetworkInfo.html">NetworkInfo</a>: Describes the status of a network interface of a given type (currently either Mobile or Wi-Fi).</li>
</ul>


<p>下面示例了检查WiFi与Mobile是否连接上(请注意available与isConnected的区别)：
```java
private static final String DEBUG_TAG = "NetworkStatusExample";
...
ConnectivityManager connMgr = (ConnectivityManager)</p>

<pre><code>    getSystemService(Context.CONNECTIVITY_SERVICE);
</code></pre>

<p>NetworkInfo networkInfo = connMgr.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
boolean isWifiConn = networkInfo.isConnected();
networkInfo = connMgr.getNetworkInfo(ConnectivityManager.TYPE_MOBILE);
boolean isMobileConn = networkInfo.isConnected();
Log.d(DEBUG_TAG, "Wifi connected: " + isWifiConn);
Log.d(DEBUG_TAG, "Mobile connected: " + isMobileConn);
```</p>

<p>一个更简单的检查网络是否可用的示例如下：</p>

<p>```java
public boolean isOnline() {</p>

<pre><code>ConnectivityManager connMgr = (ConnectivityManager) 
        getSystemService(Context.CONNECTIVITY_SERVICE);
NetworkInfo networkInfo = connMgr.getActiveNetworkInfo();
return (networkInfo != null &amp;&amp; networkInfo.isConnected());
</code></pre>

<p>}
```</p>

<p>你可以使用<a href="http://developer.android.com/reference/android/net/NetworkInfo.DetailedState.html">NetworkInfo.DetailedState</a>, 来获取更加详细的网络信息。</p>

<h2>Manage Network Usage(管理网络使用)</h2>

<p>你可以实现一个偏好设置的activity ，来允许用户设置程序的网络资源的使用。例如:</p>

<ul>
<li>你可以允许用户在仅仅连接到WiFi时上传视频。</li>
<li>你可以根据诸如网络可用等条件来选择是否做同步的操作。</li>
</ul>


<p>网络操作需要添加下面的权限：</p>

<ul>
<li><a href="http://developer.android.com/reference/android/Manifest.permission.html#INTERNET">android.permission.INTERNET</a>—Allows applications to open network sockets.</li>
<li><a href="http://developer.android.com/reference/android/Manifest.permission.html#ACCESS_NETWORK_STATE">android.permission.ACCESS_NETWORK_STATE</a>—Allows applications to access information about networks.</li>
</ul>


<p>你可以为你的设置Activity声明intent filter for the ACTION_MANAGE_NETWORK_USAGE action (introduced in Android 4.0),这样你的这个activity就可以提供数据控制的选项了。在章节概览提供的Sample中，这个action is handled by the class SettingsActivity, 它提供了偏好设置UI来让用户决定何时进行下载。</p>

<p>```xml
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"</p>

<pre><code>package="com.example.android.networkusage"
...&gt;

&lt;uses-sdk android:minSdkVersion="4" 
       android:targetSdkVersion="14" /&gt;

&lt;uses-permission android:name="android.permission.INTERNET" /&gt;
&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt;

&lt;application
    ...&gt;
    ...
    &lt;activity android:label="SettingsActivity" android:name=".SettingsActivity"&gt;
         &lt;intent-filter&gt;
            &lt;action android:name="android.intent.action.MANAGE_NETWORK_USAGE" /&gt;
            &lt;category android:name="android.intent.category.DEFAULT" /&gt;
      &lt;/intent-filter&gt;
    &lt;/activity&gt;
&lt;/application&gt;
</code></pre>

<p></manifest>
```</p>

<h2>Implement a Preferences Activity(实现一个偏好设置activity)</h2>

<p>正如上面看到的那样，SettingsActivity is a subclass ofPreferenceActivity.</p>

<p>所实现的功能见下图：</p>

<p><img src="/images/articles/network-settings1.png" alt="network-settings1.png" />
<img src="/images/articles/network-settings2.png" alt="network-settings2.png" /></p>

<p>下面是一个 SettingsActivity. 请注意它实现了OnSharedPreferenceChangeListener. 当用户改变了他的偏好，就会触发 onSharedPreferenceChanged(), 这个方法会设置refreshDisplay 为true(这里的变量存在于自己定义的activity，见下一部分的代码示例). 这会使的当用户返回到main activity的时候进行refresh。(请注意，代码中的注释，不得不说，Googler写的Code看起来就是舒服)</p>

<p>```java
public class SettingsActivity extends PreferenceActivity implements OnSharedPreferenceChangeListener {</p>

<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    // Loads the XML preferences file
    addPreferencesFromResource(R.xml.preferences);
}

@Override
protected void onResume() {
    super.onResume();

    // Registers a listener whenever a key changes            
    getPreferenceScreen().getSharedPreferences().registerOnSharedPreferenceChangeListener(this);
}

@Override
protected void onPause() {
    super.onPause();

   // Unregisters the listener set in onResume().
   // It's best practice to unregister listeners when your app isn't using them to cut down on 
   // unnecessary system overhead. You do this in onPause().            
   getPreferenceScreen().getSharedPreferences().unregisterOnSharedPreferenceChangeListener(this);    
}

// When the user changes the preferences selection, 
// onSharedPreferenceChanged() restarts the main activity as a new
// task. Sets the the refreshDisplay flag to "true" to indicate that 
// the main activity should update its display.
// The main activity queries the PreferenceManager to get the latest settings.

@Override
public void onSharedPreferenceChanged(SharedPreferences sharedPreferences, String key) {    
    // Sets refreshDisplay to true so that when the user returns to the main
    // activity, the display refreshes to reflect the new settings.
    NetworkActivity.refreshDisplay = true;
}
</code></pre>

<p>}
```</p>

<h2>Respond to Preference Changes(对偏好改变进行响应)</h2>

<p>当用户在设置界面改变了偏好，它通常都会对app的行为产生影响。
在下面的代码示例中，app会在onStart(). 方法里面检查偏好设置。如果设置的类型与当前设备的网络连接类型相一致，那么程序就会下载数据并刷新显示。(for example, if the setting is "Wi-Fi" and the device has a Wi-Fi connection)。(这是一个很好的代码示例，如何选择合适的网络类型进行下载操作)
```java
public class NetworkActivity extends Activity {</p>

<pre><code>public static final String WIFI = "Wi-Fi";
public static final String ANY = "Any";
private static final String URL = "http://stackoverflow.com/feeds/tag?tagnames=android&amp;sort=newest";

// Whether there is a Wi-Fi connection.
private static boolean wifiConnected = false; 
// Whether there is a mobile connection.
private static boolean mobileConnected = false;
// Whether the display should be refreshed.
public static boolean refreshDisplay = true;

// The user's current network preference setting.
public static String sPref = null;

// The BroadcastReceiver that tracks network connectivity changes.
private NetworkReceiver receiver = new NetworkReceiver();

@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    // Registers BroadcastReceiver to track network connection changes.
    IntentFilter filter = new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);
    receiver = new NetworkReceiver();
    this.registerReceiver(receiver, filter);
}

@Override 
public void onDestroy() {
    super.onDestroy();
    // Unregisters BroadcastReceiver when app is destroyed.
    if (receiver != null) {
        this.unregisterReceiver(receiver);
    }
}

// Refreshes the display if the network connection and the
// pref settings allow it.

@Override
public void onStart () {
    super.onStart();  

    // Gets the user's network preference settings
    SharedPreferences sharedPrefs = PreferenceManager.getDefaultSharedPreferences(this);

    // Retrieves a string value for the preferences. The second parameter
    // is the default value to use if a preference value is not found.
    sPref = sharedPrefs.getString("listPref", "Wi-Fi");

    updateConnectedFlags(); 

    if(refreshDisplay){
        loadPage();    
    }
}

// Checks the network connection and sets the wifiConnected and mobileConnected
// variables accordingly. 
public void updateConnectedFlags() {
    ConnectivityManager connMgr = (ConnectivityManager) 
            getSystemService(Context.CONNECTIVITY_SERVICE);

    NetworkInfo activeInfo = connMgr.getActiveNetworkInfo();
    if (activeInfo != null &amp;&amp; activeInfo.isConnected()) {
        wifiConnected = activeInfo.getType() == ConnectivityManager.TYPE_WIFI;
        mobileConnected = activeInfo.getType() == ConnectivityManager.TYPE_MOBILE;
    } else {
        wifiConnected = false;
        mobileConnected = false;
    }  
}

// Uses AsyncTask subclass to download the XML feed from stackoverflow.com.
public void loadPage() {
    if (((sPref.equals(ANY)) &amp;&amp; (wifiConnected || mobileConnected))
            || ((sPref.equals(WIFI)) &amp;&amp; (wifiConnected))) {
        // AsyncTask subclass
        new DownloadXmlTask().execute(URL);
    } else {
        showErrorPage();
    }
}
</code></pre>

<p>...</p>

<p>}
```</p>

<h2>Detect Connection Changes(监测网络连接的改变)</h2>

<p>最后一部分是关于 BroadcastReceiver 的子类： NetworkReceiver. 当设备网络连接改变时，NetworkReceiver会监听到 CONNECTIVITY_ACTION, 这时需要判断当前网络连接类型并相应的设置好 wifiConnected 与 mobileConnected .</p>

<p>我们需要控制好BroadcastReceiver的使用，不必要的声明注册会浪费系统资源。通常是在 onCreate() 去registers 这个BroadcastReceiver ， 在onPause()或者onDestroy() 时unregisters它。这样做会比直接在manifest里面直接注册 <receiver> 更轻量. 当你在manifest里面注册了一个 <receiver> ，你的程序可以在任何时候被唤醒, 即使你已经好几个星期没有使用这个程序了。而通过前面的办法进行注册，可以确保用户离开你的程序之后，不会因为那个Broadcast而被唤起。如果你确保知道何时需要使用到它，你可以在合适的地方使用 <a href="http://developer.android.com/reference/android/content/pm/PackageManager.html#setComponentEnabledSetting(android.content.ComponentName,%20int,%20int">setComponentEnabledSetting()</a>) 来开启或者关闭它。</p>

<p>```java
public class NetworkReceiver extends BroadcastReceiver {</p>

<p>@Override
public void onReceive(Context context, Intent intent) {</p>

<pre><code>ConnectivityManager conn =  (ConnectivityManager)
    context.getSystemService(Context.CONNECTIVITY_SERVICE);
NetworkInfo networkInfo = conn.getActiveNetworkInfo();

// Checks the user prefs and the network connection. Based on the result, decides whether
// to refresh the display or keep the current display.
// If the userpref is Wi-Fi only, checks to see if the device has a Wi-Fi connection.
if (WIFI.equals(sPref) &amp;&amp; networkInfo != null &amp;&amp; networkInfo.getType() == ConnectivityManager.TYPE_WIFI) {
    // If device has its Wi-Fi connection, sets refreshDisplay
    // to true. This causes the display to be refreshed when the user
    // returns to the app.
    refreshDisplay = true;
    Toast.makeText(context, R.string.wifi_connected, Toast.LENGTH_SHORT).show();

// If the setting is ANY network and there is a network connection
// (which by process of elimination would be mobile), sets refreshDisplay to true.
} else if (ANY.equals(sPref) &amp;&amp; networkInfo != null) {
    refreshDisplay = true;

// Otherwise, the app can't download content--either because there is no network
// connection (mobile or Wi-Fi), or because the pref setting is WIFI, and there 
// is no Wi-Fi connection.
// Sets refreshDisplay to false.
} else {
    refreshDisplay = false;
    Toast.makeText(context, R.string.lost_connection, Toast.LENGTH_SHORT).show();
}
</code></pre>

<p>}
```</p>

<hr />

<p><strong>学习自：<a href="http://developer.android.com/training/basics/network-ops/managing.html">http://developer.android.com/training/basics/network-ops/managing.html</a>，请多指教，谢谢！</strong><br/>
<strong>转载请注明出自<a href="http://kesenhoo.github.com">http://kesenhoo.github.com</a>，谢谢配合！</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Training Connectivity - 执行网络操作(Lesson 1 - HTTP连接网络)]]></title>
    <link href="http://kesenhoo.github.com/blog/2012/05/03/android-training-connectivity-network-operations-lesson-1/"/>
    <updated>2012-05-03T15:21:00+08:00</updated>
    <id>http://kesenhoo.github.com/blog/2012/05/03/android-training-connectivity-network-operations-lesson-1</id>
    <content type="html"><![CDATA[<p>这一章会介绍一些基本的网络操作，监视网络链接（包括网络改变），让用户来控制app对网络的选择使用。还会介绍如何解析与使用XML数据。</p>

<p><a href="http://developer.android.com/shareables/training/NetworkUsage.zip">NetworkUsage.zip</a></p>

<p>通过学习这章节的课程，你已经会学习一些基础知识，如何在最小化网络阻塞的情况下，创建一个高效的app，用来下载数据与解析数据。</p>

<p>你还可以参考下面文章进阶学习:</p>

<ul>
<li><a href="http://developer.android.com/training/monitoring-device-state/index.html">Optimizing Battery Life</a></li>
<li><a href="http://developer.android.com/training/efficient-downloads/index.html">Transferring Data Without Draining the Battery</a></li>
<li><a href="http://developer.android.com/guide/webapps/index.html">Web Apps Overview</a></li>
</ul>


<!-- more -->


<p><strong>第1课:Connecting to the Network</strong></p>

<p>这一课会演示如何实现一个简单的连接到网络的程序。它提供了一些你应该follow的最好示例，用来创建最简单的网络连接程序。请注意，想要执行网络操作首先需要在程序的manifest文件中添加下面的permissions:
<code>xml
&lt;uses-permission android:name="android.permission.INTERNET" /&gt;
&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt;
</code></p>

<h2>Choose an HTTP Client(选择一个HTTP Client)</h2>

<p>大多数连接网络的Android app会使用HTTP来发送与接受数据。Android提供了两种HTTP clients: <a href="http://developer.android.com/reference/java/net/HttpURLConnection.html">HttpURLConnection</a> 与Apache <a href="http://developer.android.com/reference/org/apache/http/client/HttpClient.html">HttpClient</a>。他们二者均支持HTTPS ，都以流方式进行上传与下载，都有可配置timeout, IPv6 与连接池（connection pooling）. <strong>推荐从Gingerbread版本开始使用 HttpURLConnection</strong> 。关于这部分的更多详情，请参考 <a href="http://android-developers.blogspot.com/2011/09/androids-http-clients.html">Android's HTTP Clients</a>。</p>

<h2>Check the Network Connection(检测网络连接)</h2>

<p>在你的app尝试进行网络连接之前，需要检测当前是否有可用的网络。请注意，设备可能会不在网络覆盖范围内，或者用户可能关闭Wi-Fi与移动网络连接。关于这方面更多的资料，请参考：Managing Network Usage.(<em>下一课内容</em>)
```java
public void myClickHandler(View view) {</p>

<pre><code>...
ConnectivityManager connMgr = (ConnectivityManager) 
    getSystemService(Context.CONNECTIVITY_SERVICE);
NetworkInfo networkInfo = connMgr.getActiveNetworkInfo();
if (networkInfo != null &amp;&amp; networkInfo.isConnected()) {
    // fetch data
} else {
    // display error
}
...
</code></pre>

<p>}
```</p>

<h2>Perform Network Operations on a Separate Thread(在另外一个Thread执行网络操作)</h2>

<p>网络操作会遇到不可预期的延迟。显然为了避免一个不好的用户体验，总是在UI Thread之外去执行网络操作。AsyncTask 类提供了一种简单的方式来处理这个问题。关于更多的详情，请参考： <a href="http://android-developers.blogspot.com/2010/07/multithreading-for-performance.html">Multithreading For Performance</a>.</p>

<p>在下面的代码示例中，myClickHandler() 方法会触发一个新的DownloadWebpageTask().execute(stringUrl). 它继承自AsyncTask，实现了下面两个方法:</p>

<ul>
<li><a href="http://developer.android.com/reference/android/os/AsyncTask.html#doInBackground(Params...">doInBackground()</a>) 执行 downloadUrl()方法。Web URL作为参数，方法downloadUrl() 获取并处理网页返回的数据，执行完毕后，传递结果到onPostExecute()。参数类型为String.</li>
<li><a href="http://developer.android.com/reference/android/os/AsyncTask.html#onPostExecute(Result">onPostExecute()</a>) 获取到返回数据并显示到UI上。</li>
</ul>


<p>```java
public class HttpExampleActivity extends Activity {</p>

<pre><code>private static final String DEBUG_TAG = "HttpExample";
private EditText urlText;
private TextView textView;

@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.main);   
    urlText = (EditText) findViewById(R.id.myUrl);
    textView = (TextView) findViewById(R.id.myText);
}

// When user clicks button, calls AsyncTask.
// Before attempting to fetch the URL, makes sure that there is a network connection.
public void myClickHandler(View view) {
    // Gets the URL from the UI's text field.
    String stringUrl = urlText.getText().toString();
    ConnectivityManager connMgr = (ConnectivityManager) 
        getSystemService(Context.CONNECTIVITY_SERVICE);
    NetworkInfo networkInfo = connMgr.getActiveNetworkInfo();
    if (networkInfo != null &amp;&amp; networkInfo.isConnected()) {
        new DownloadWebpageText().execute(stringUrl);
    } else {
        textView.setText("No network connection available.");
    }
}

 // Uses AsyncTask to create a task away from the main UI thread. This task takes a 
 // URL string and uses it to create an HttpUrlConnection. Once the connection
 // has been established, the AsyncTask downloads the contents of the webpage as
 // an InputStream. Finally, the InputStream is converted into a string, which is
 // displayed in the UI by the AsyncTask's onPostExecute method.
 private class DownloadWebpageText extends AsyncTask {
    @Override
    protected String doInBackground(String... urls) {

        // params comes from the execute() call: params[0] is the url.
        try {
            return downloadUrl(urls[0]);
        } catch (IOException e) {
            return "Unable to retrieve web page. URL may be invalid.";
        }
    }
    // onPostExecute displays the results of the AsyncTask.
    @Override
    protected void onPostExecute(String result) {
        textView.setText(result);
   }
}
...
</code></pre>

<p>}
```</p>

<p>关于上面那段代码的示例详解，请参考下面:</p>

<ul>
<li>When users click the button that invokes myClickHandler(), the app passes the specified URL to the AsyncTask subclass DownloadWebpageTask.</li>
<li>The AsyncTask method doInBackground() calls the downloadUrl() method.</li>
<li>The downloadUrl() method takes a URL string as a parameter and uses it to create a URL object.</li>
<li>The URL object is used to establish an HttpURLConnection.</li>
<li>Once the connection has been established, the HttpURLConnection object fetches the web page content as an InputStream.</li>
<li>The InputStream is passed to the readIt() method, which converts the stream to a string.</li>
<li>Finally, the AsyncTask's onPostExecute() method displays the string in the main activity's UI.</li>
</ul>


<h2>Connect and Download Data(连接并下载数据)</h2>

<p>在执行网络交互的线程里面，你可以使用 HttpURLConnection 来执行一个 GET 类型的操作并下载数据。在你调用 connect()之后，你可以通过调用getInputStream()来得到一个包含数据的<a href="http://developer.android.com/reference/java/io/InputStream.html">InputStream</a> 对象。</p>

<p>在下面的代码示例中， doInBackground() 方法会调用downloadUrl(). 这个 downloadUrl() 方法使用给予的URL，通过 HttpURLConnection 连接到网络。一旦建立连接，app使用 getInputStream() 来获取数据。</p>

<p>```java
// Given a URL, establishes an HttpUrlConnection and retrieves
// the web page content as a InputStream, which it returns as
// a string.
private String downloadUrl(String myurl) throws IOException {</p>

<pre><code>InputStream is = null;
// Only display the first 500 characters of the retrieved
// web page content.
int len = 500;

try {
    URL url = new URL(myurl);
    HttpURLConnection conn = (HttpURLConnection) url.openConnection();
    conn.setReadTimeout(10000 /* milliseconds */);
    conn.setConnectTimeout(15000 /* milliseconds */);
    conn.setRequestMethod("GET");
    conn.setDoInput(true);
    // Starts the query
    conn.connect();
    int response = conn.getResponseCode();
    Log.d(DEBUG_TAG, "The response is: " + response);
    is = conn.getInputStream();

    // Convert the InputStream into a string
    String contentAsString = readIt(is, len);
    return contentAsString;

// Makes sure that the InputStream is closed after the app is
// finished using it.
} finally {
    if (is != null) {
        is.close();
    } 
}
</code></pre>

<p>}
```</p>

<p>请注意，getResponseCode() 会返回连接状态码( status code). 这是一种获知额外网络连接信息的有效方式。status code 是 200 则意味着连接成功.</p>

<h2>Convert the InputStream to a String(把InputStream的数据转换为String)</h2>

<p>InputStream 是一种可读的byte数据源。如果你获得了一个 InputStream, 通常会进行decode或者转换为制定的数据类型。例如，如果你是在下载一张image数据，你可能需要像下面一下进行decode：
<code>java
InputStream is = null;
...
Bitmap bitmap = BitmapFactory.decodeStream(is);
ImageView imageView = (ImageView) findViewById(R.id.image_view);
imageView.setImageBitmap(bitmap);
</code></p>

<p>在上面演示的示例中， InputStream 包含的是web页面的文本内容。下面会演示如何把 InputStream 转换为string，以便显示在UI上。</p>

<p>```java
// Reads an InputStream and converts it to a String.
public String readIt(InputStream stream, int len) throws IOException, UnsupportedEncodingException {</p>

<pre><code>Reader reader = null;
reader = new InputStreamReader(stream, "UTF-8");
char[] buffer = new char[len];
reader.read(buffer);
return new String(buffer);
</code></pre>

<p>}
```</p>

<hr />

<p><strong>学习自：<a href="http://developer.android.com/training/basics/network-ops/connecting.html">http://developer.android.com/training/basics/network-ops/connecting.html</a>，请多指教，谢谢！</strong><br/>
<strong>转载请注明出自<a href="http://kesenhoo.github.com">http://kesenhoo.github.com</a>，谢谢配合！</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Training Connectivity - 优化下载效率(Lesson 1 - 用有效率的网络访问方式来优化下载)]]></title>
    <link href="http://kesenhoo.github.com/blog/2012/03/25/android-training-connectivity-transferring-data-without-draining-the-battery-lesson-1/"/>
    <updated>2012-03-25T16:54:00+08:00</updated>
    <id>http://kesenhoo.github.com/blog/2012/03/25/android-training-connectivity-transferring-data-without-draining-the-battery-lesson-1</id>
    <content type="html"><![CDATA[<p>在这一章，我们将学习为了最小化某些操作对电量的影响是如何处理下载，网络连接，尤其是无线电连接的。
下面几节课会演示了如何使用缓存caching，轮询polling，预取prefetching等技术来计划与执行下载操作。
我们还会学习无线电波的power-use属性配置是如何影响我们对于在何时，用什么，以何种方式来传输数据的选择。
当然这些选择是为了最小化对电池寿命的影响。</p>

<p><strong>Dependencies and prerequisites</strong><br/>
Android 2.0 (API Level 5) or higher</p>

<p><strong>You should also read</strong><br/>
<a href="http://developer.android.com/training/monitoring-device-state/index.html">Optimizing Battery Life</a></p>

<h2>Lessons</h2>

<ul>
<li><strong>Optimizing Downloads for Efficient Network Access[使用有效的网络连接方式来最优化下载]</strong><br/>
This lesson introduces the wireless radio state machine, explains how your app’s connectivity model interacts with it, and how you can minimize your data connection and use prefetching and bundling to minimize the battery drain associated with your data transfers.</li>
</ul>


<!-- more -->


<ul>
<li><p><strong>Minimizing the Effect of Regular Updates[优化常规更新操作的效果]</strong><br/>
This lesson will examine how your refresh frequency can be varied to best mitigate the effect of background updates on the underlying wireless radio state machine.</p></li>
<li><p><strong>Redundant Downloads are Redundant[重复的下载是冗余的]</strong><br/>
The most fundamental way to reduce your downloads is to download only what you need. This lesson introduces some best practices to eliminate redundant downloads.</p></li>
<li><p><strong>Modifying your Download Patterns Based on the Connectivity Type[根据网络连接类型来更改下载模式]</strong><br/>
When it comes to impact on battery life, not all connection types are created equal. Not only does the Wi-Fi radio use significantly less battery than its wireless radio counterparts, but the radios used in different wireless radio technologies have different battery implications.</p></li>
</ul>


<h2>第1课：Optimizing Downloads for Efficient Network Access[用有效的网络访问来最优化下载]</h2>

<p>也许使用无线电波(wireless radio)进行传输数据会是我们app最耗电的操作之一。所以为了最小化网络连接的电量消耗，懂得连接模式(connectivity model)会如何影响底层的音频硬件设备是至关重要的。
这节课介绍了无线电波状态机(wireless radio state machine)，并解释了app的connectivity model是如何与状态机进行交互的。然后会提出建议的方法来最小化我们的数据连接，使用预取(prefetching)与捆绑(bundle)的方式进行数据的传输，这些操作都是为了最小化电量的消耗。</p>

<h2>The Radio State Machine[无线电状态机]</h2>

<p>一个完全活动的无线电会消耗很大部分的电量，因此需要学习如何在不同状态下进行过渡，这样能够避免电量的浪费。
典型的3G无线电网络有三种能量状态：</p>

<ul>
<li><strong>Full power</strong>: 当无线连接被激活的时候，允许设备以最大的传输速率进行操作。</li>
<li><strong>Low power</strong>: 相对Full power来说，算是一种中间状态，差不多50%的传输速率。</li>
<li><strong>Standby</strong>: 最低的状态，没有数据连接需要传输。</li>
</ul>


<p>在最低并且空闲的状态下，电量消耗相对来说是少的。
这里需要介绍一延时(latency)的机制，从low status返回到full status大概需要花费1.5秒，从idle status返回到full status需要花费2秒。
为了最小化延迟，状态机使用了一种后滞过渡到更低能量状态的机制。下图是一个典型的3G无线电波状态机的图示(AT&amp;T电信的一种制式).</p>

<p><img src="/images/articles/mobile_radio_state_machine.png" title="Figure 1. Typical 3G wireless radio state machine." alt="mobile_radio_state_machine.png" /></p>

<ul>
<li>在每一台设备上的无线状态机都会根据无线电波的制式(2G,3G,LTE等)而改变，并且由设备本身自己所使用的网络进行定义与配置。</li>
<li>这一课描述了一种典型的3G无线电波状态机，<a href="http://www.research.att.com/articles/featured_stories/2011_03/201102_Energy_efficient?fbid=SYuI20FzBum">data provided by AT&amp;T</a>。这些原理是具有通用性的，在其他的无线电波上同样适用。</li>
<li>这种方法在浏览通常的网页操作上是特别有效的，因为它可以阻止一些不必要的浪费。而且相对较短的后期处理时间也保证了当一个session结束的时候，无线电波可以转移到相对较低的能量状态。</li>
<li>不幸的是，这个方法会导致在现代的智能机系统例如Android上的apps效率低下。因为Android上的apps不仅仅可以在前台运行，也可以在后台运行。[无线电波的状态改变会影响到本来的设计，有些想在前台运行的可能会因为切换到低能量状态而影响程序效率。坊间说手机在电量低的状态下无线电波的强度会增大好几倍来保证信号，可能与这个有关]</li>
</ul>


<h2>How Apps Impact the Radio State Machine[看apps如何影响无线状态机（使用bundle与unbundle传输数据的差异）]</h2>

<p>每一次新创建一个网络连接，无线电波就切换到full power状态。在上面典型的3G无线电波状态机情况下，无线电波会在传输数据时保持在full power的状态，结束之后会有一个附加的5秒时间切换到low power,再之后会经过12秒进入到low  energy的状态。因此对于典型的3G设备，每一次数据传输的会话都会引起无线电波都会持续消耗大概20秒的能量。</p>

<p>实际上，这意味着一个app传递1秒钟的unbundled data会使得无线电波持续活动18秒【18=1秒的传输数据+5秒过渡时间回到low power+12秒过渡时间回到standby】。因此每一分钟，它会消耗18秒high power的电量，42秒的low power的电量。</p>

<p>通过比较，如果每分钟app会传输bundle的data持续3秒的话，其中会使得无线电波持续在high power状态仅仅8秒钟，在low power状态仅仅12秒钟。
上面第二种传输bundle data的例子，可以看到减少了大量的电量消耗。图示如下：</p>

<p><img src="/images/articles/graphs.png" title="Figure 2. Relative wireless radio power use for bundled versus unbundled transfers." alt="graphs.png" /></p>

<h2>Prefetch Data[预取数据]</h2>

<p>预取(Prefetching)数据是一种减少独立数据传输会话数量的有效方法。预取技术允许你在单次操作的时候，通过一次连接，在最大能力下，根据给出的时间下载到所有的数据。</p>

<p>通过前面的传输数据的技术，你减少了大量的无线电波激活时间。这样的话，不仅仅是保存了电量，也提高了潜在风险【看下面讲解】，降低了带宽，减少了下载时间。</p>

<p>预取技术提供了一种提高用户体验的方法，通过减少可能因为下载时间过长而导致预览后者后续操作等待漫长。</p>

<p>然而，使用预取技术过于频繁，不仅仅会导致电量消耗快速增长，还有可能预取到一些并不需要的数据【比如预取了10秒，用户在第3秒就已经切换掉，这个时候预取过多的就是浪费】。同样，确保app不会因为等待预取全部完成而卡到程序的开始播放也是非常重要的。从实践的角度，那意味着需要逐步处理数据，并且按照有优先级的顺序开始进行数据传递，这样能确保不卡到程序的开始播放的同时数据也能够得到持续的下载。</p>

<p>那么应该如何控制预取的操作呢？这需要根据正在下载的数据大小与可能被用到的数据量来决定。一个基于上面状态机情况的比较大概的建议是：对于数据来说，大概有50%的机会可能用在当前用户的会话中，那么我们可以预取大约6秒(大约1-2Mb)，这大概使得潜在可能要用的数据量与可能已经下载好的数据量相一致。</p>

<p>通常来说，预取1-5Mb会比较好，这种情况下，我们仅仅只需要每隔2-5分钟开始另一段下载。【3G网络是这样吗？】根据这个原理，大数据的下载，比如视频文件，应该每隔2-5秒开始另一段下载，这样能有效的预取到下面几分钟内的数据进行预览。</p>

<p>值得注意的是，下载需要是bundled的形式，而且上面那些大概的数据与时间可能会根据网络连接的类型与速度有所变化，这些都将在下面两部分内容讲到。</p>

<p>让我们来看一些例子：</p>

<p><strong>A music player</strong>
你可以选择预取整个专辑，然而这样用户在第一首歌曲之后停止监听，那么就浪费了大量的带宽于电量。
一个比较好的方法是维护一首歌曲的缓冲区。对于流媒体音乐，不应该去维护一段连续的数据流，因为这样会使得无线电波一直保持激活状态，应该考虑把HTTP的数据流集中一次传输到音频流，就像上面描述的预取技术一样(下载好2Mb，然后开始一次取出，再去下载下面的2Mb)。</p>

<p><strong>A news reader</strong>
许多news apps尝试通过只下载新闻标题来减少带宽，完整的文章仅在用户想要读取的时候再去读取，而且文章也会因为太长而刚开始只显示部分信息，等用户下滑时再去读取完整信息。
使用这个方法，无线电波仅仅会在用户点击更多信息的时候才会被激活。但是，在切换文章分类预阅读文章的时候仍然会造成大量潜在的消耗。【因为无线电波有几十秒的过渡期】</p>

<p>一个比较好的方法是在启动的时候预取一个合理数量的数据，比如在启动的时候预取一些文章的标题【免得切换分类时又去获取这个栏目下的头条】与缩略图信息。之后开始获取剩余的标题预缩略信息。</p>

<p>另一个方法是预取所有的标题，缩略信息，文章文字，甚至是所有文章的图片-根据既设的后台程序进行逐一获取。这样做的风险是花费了大量的带宽与电量去下载一些不会阅读到的内容，因此这需要比较小心思考是否合适。其中的一个解决方案是，当在连接至Wi-Fi时有计划的下载所有的内容，并且如果有可能最好是设备正在充电的时候。关于这个的细节的实现，我们将在后面的课程中涉及到。【这让我想起了网易新闻的离线下载，在连接到Wi-Fi的时候，可以选择下载所有的内容到本地，之后直接打开阅读】</p>

<h2>Batch Transfers and Connections[批量传输与连接]</h2>

<p>使用典型3G无线网络制式的时候，每一次初始化一个连接(与需要传输的数据量无关)，你都有可能导致无线电波持续花费大约20秒的电量。</p>

<p>一个app，若是每20秒进行一次ping server的操作，假设这个app是正在运行且对用户可见，那么这会导致无线电波不确定什么时候被开启，最终可能使得电量花费在没有实际传输数据的情况下。</p>

<p>因此，对数据进行bundle操作并且创建一个序列来存放这些bundle好的数据就显的非常重要。操作正确的话，可以使得大量的数据集中进行发送，这样使得无线电波的激活时间尽可能的少，同时减少大部分电量的花费。这样做的潜在好处是尽可能在每次传输数据的会话中尽可能多的传输数据而且减少了会话的次数。</p>

<p>例如：新闻客户端可以分析用户的使用行为习惯，根据这些习惯来做决定如何获取数据，获取多少，什么时候获取等。在这个例子中，所有收集到的用户习惯应该捆绑一起，之后再一起进行发送，而不是每次点击的行为都去发送这个碎片数据。同时，发送这些数据不应该在下载一个全图或者执行例行更新的时候去操作。</p>

<h2>Reduce Connections[减少连接次数]</h2>

<p>重用已经存在的网络连接比起重新建立一个新的连接通常来说是更有效率的。重用网络连接同样可以使得在拥挤不堪的网络环境中进行更加智能的互动。当可以捆绑所有请求在一个GET里面的时候不要同时创建多个网络连接或者把多个GET请求进行串联。</p>

<p>例如，可以一起请求所有文章的情况下，不要根据多个栏目进行多次请求。无线电波会在等待接受返回信息或者timeout信息之前保持激活状态，所以如果不需要的连接请立即关闭而不是等待他们timeout。</p>

<p>之前说道，如果关闭一个连接过于及时，会导致后面再次请求时重新建立一个在Server与Client之间的连接，而我们说过要尽量避免建立重复的连接，那么有个有效的折中办法是不要立即关闭，而是在timeout之前关闭(即稍微晚点却又不至于到timeout)。</p>

<p><strong>Note</strong>:使用HttpUrlConnection，而不是Apache的HttpClient,前者有做response cache.</p>

<h2>Use the DDMS Network Traffic Tool to Identify Areas of Concern[使用DDMS网络通信工具来检测网络使用情况]</h2>

<p>The Android <a href="http://developer.android.com/guide/developing/debugging/ddms.html">DDMS (Dalvik Debug Monitor Server)</a> 包含了一个查看网络使用详情的栏目来允许跟踪app的网络请求。使用这个工具，可以监测app是在何时，如何传输数据的，从而可以进行代码的优化。</p>

<p>下图显示了传输少量的网络模型，可以看到每次差不多相隔15秒，这意味着可以通过预取技术或者批量上传来大幅提高效率。</p>

<p><img src="/images/articles/DDMS.png" title="Figure 3. Tracking network usage with DDMS." alt="DDMS.png" /></p>

<p>通过监测数据传输的频率与每次传输的数据量，可以查看出哪些位置应该进行优化，通常的，图中显示的短小的类似钉子形状的位置，可以进行与附近位置的请求进行做merge的动作。</p>

<p>为了更好的检测出问题所在，<strong>Traffic Status API</strong>允许你使用<strong>TrafficStats.setThreadStatsTag()</strong>的方法标记数据传输发生在某个Thread里面，然后可以手动的使用tagSocket()进行标记到或者使用untagSocket()来取消标记，例如：</p>

<p><code>java
TrafficStats.setThreadStatsTag(0xF00D);  
TrafficStats.tagSocket(outputSocket);  
// Transfer data using socket  
TrafficStats.untagSocket(outputSocket);
</code></p>

<p>Apache的HttpClient与URLConnection库可以自动tag sockets使用当前getThreadStatusTag()的值。那些库在通过keep-alive pools循环的时候也会tag与untag sockets。</p>

<p><code>java
TrafficStats.setThreadStatsTag(0xF00D);  
try {  
  // Make network request using HttpClient.execute()  
} finally {  
  TrafficStats.clearThreadStatsTag();  
}
</code></p>

<p>Socket tagging 是在Android 4.0上才被支持的, 但是实际情况是仅仅会在运行Android 4.0.3 or higher的设备上才会显示.</p>

<hr />

<p>后记：哇，这节课太长了，不过很值得我们学习并注意，Radio state machine，Prefetch，Bundle等，在实际项目中，可能很少有人注意到这些，这也是Google开设这一系列课程的价值所在，提高app的质量，用更少的资源做更多的事情。</p>

<p><strong>学习自：<a href="http://developer.android.com/training/efficient-downloads/efficient-network-access.html">http://developer.android.com/training/efficient-downloads/efficient-network-access.html</a>，请多指教，谢谢！</strong><br/>
<strong>转载请注明出自<a href="http://kesenhoo.github.com">http://kesenhoo.github.com</a>，谢谢配合！</strong></p>
]]></content>
  </entry>
  
</feed>
