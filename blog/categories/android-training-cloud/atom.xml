<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android:Training:Cloud | 胡凯]]></title>
  <link href="http://hukai.me/blog/categories/android-training-cloud/atom.xml" rel="self"/>
  <link href="http://hukai.me/"/>
  <updated>2014-03-31T14:06:25+08:00</updated>
  <id>http://hukai.me/</id>
  <author>
    <name><![CDATA[Kesen Hoo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android Training[Cloud] - 云同步(Lesson 2 - 使用Backup API)]]></title>
    <link href="http://hukai.me/blog/2012/04/22/android-training-cloud-syncing-to-the-cloud-lesson-2/"/>
    <updated>2012-04-22T18:27:00+08:00</updated>
    <id>http://hukai.me/blog/2012/04/22/android-training-cloud-syncing-to-the-cloud-lesson-2</id>
    <content type="html"><![CDATA[<h2>Using the Backup API[使用Backup API]</h2>

<p>当一个用户购买了新的设备或者是把当前的设备做了的恢复出厂设置的操作，用户希望在进行初始化设置的时候，Google Play能够把之前安装过的应用恢复到设备上。默认情况是，那些操作不会发生，用户之前的设置与数据都会丢失.</p>

<p>对于一些数据量相对较少的情况下(通常少于1MB)，例如用户偏好设置，笔记，游戏分数或者是其他的一些状态数据，可以使用Backup API来提供一个轻量级的解决方案。这一课会介绍如何使用Backup API.</p>

<h2>(1)Register for the Android Backup Service[为Android备份服务进行注册]</h2>

<p>这一课会使用Android Backup Service, 它需要进行注册. 点击这个链接进行注册:<a href="http://code.google.com/android/backup/signup.html">register here</a>. 注册成功后，服务器会提供一段类似下面的代码用来添加到程序的Manifest文件中:</p>

<!-- More -->


<p><code>xml
&lt;meta-data android:name="com.google.android.backup.api_key"
android:value="ABcDe1FGHij2KlmN3oPQRs4TUvW5xYZ" /&gt;
</code>
请注意，每一个备份key都只能在特定的包名下工作，如果你有不同的程序需要使用这个方法进行备份，那么需要为他们分别进行注册。</p>

<h2>(2)Configure Your Manifest[确认你的Manifest]</h2>

<p>使用Android的备份服务需要添加2个内容到你的程序Manifest中，首先，声明作为你的备份代理的类名，然后添加一段类似上面的代码作为Application标签的根标签。假设你的备份代理是TheBackupAgent, 下面演示里如何在Manifest中添加上面这些信息:
```xml
&lt;application android:label="MyApp"</p>

<pre><code>         android:backupAgent="TheBackupAgent"&gt;  
...  
&lt;meta-data android:name="com.google.android.backup.api_key"  
android:value="ABcDe1FGHij2KlmN3oPQRs4TUvW5xYZ" /&gt;  
...  
</code></pre>

<p></application>
```</p>

<h2>(3)Write Your Backup Agent[编写你的备份代理]</h2>

<p>最简单的创建你的备份代理的方法是继承<a href="http://developer.android.com/reference/android/app/backup/BackupAgentHelper.html">BackupAgentHelper</a>. 创建这个帮助类实际上是非常简单。仅仅是创建一个你上面Manifest文件中声明的类去继承BackupAgentHelper.然后重写onCreate().
在onCreate() 创建一个<a href="http://developer.android.com/reference/android/app/backup/BackupHelper.html">BackupHelper</a>. 目前Android framework包含了两种那样的帮助类: <a href="http://developer.android.com/reference/android/app/backup/FileBackupHelper.html">FileBackupHelper</a> 与 <a href="http://developer.android.com/reference/android/app/backup/SharedPreferencesBackupHelper.html">SharedPreferencesBackupHelper</a>. 在你创建一个帮助类并且指向需要备份的数据的时候，仅仅需要使用 addHelper() 方法来添加到BackupAgentHelper， 在后面再增加一个key用来retrieve数据. 大多数情况下，完整的实现差不多只需要10行代码.
```java
import android.app.backup.BackupAgentHelper;<br/>
import android.app.backup.FileBackupHelper;</p>

<p>public class TheBackupAgent extends BackupAgentHelper {</p>

<pre><code>// The name of the SharedPreferences file  
static final String HIGH_SCORES_FILENAME = "scores";  

// A key to uniquely identify the set of backup data  
static final String FILES_BACKUP_KEY = "myfiles";  

// Allocate a helper and add it to the backup agent  
@Override  
void onCreate() {  
    FileBackupHelper helper = new FileBackupHelper(this, HIGH_SCORES_FILENAME);  
    addHelper(FILES_BACKUP_KEY, helper);  
}  
</code></pre>

<p>}<br/>
<code>
为了使得程序更加灵活，FileBackupHelper的constructor可以带有一些文件名，你可以简单的通过增加一个额外的参数实现备份最高分文件与游戏程序文件，像下面一样:
</code>java
@Override<br/>
void onCreate() {<br/>
  FileBackupHelper helper = new FileBackupHelper(this, HIGH_SCORES_FILENAME, PROGRESS_FILENAME);<br/>
  addHelper(FILES_BACKUP_KEY, helper);<br/>
}
```</p>

<p>备份用户偏好同样比较简单. 像创建FileBackupHelper一样来创建一个SharedPreferencesBackupHelper。在这种情况下, 不是添加文件名到constructor,而是添加被你的程序所用的shared preference groups的名称.请看示例:
```java
import android.app.backup.BackupAgentHelper;<br/>
import android.app.backup.SharedPreferencesBackupHelper;</p>

<p>public class TheBackupAgent extends BackupAgentHelper {</p>

<pre><code>// The names of the SharedPreferences groups that the application maintains.  These  
// are the same strings that are passed to getSharedPreferences(String, int).  
static final String PREFS_DISPLAY = "displayprefs";  
static final String PREFS_SCORES = "highscores";  


// An arbitrary string used within the BackupAgentHelper implementation to  
// identify the SharedPreferencesBackupHelper's data.  
static final String MY_PREFS_BACKUP_KEY = "myprefs";  


// Simply allocate a helper and install it  
void onCreate() {  
    SharedPreferencesBackupHelper helper =  
            new SharedPreferencesBackupHelper(this, PREFS_DISPLAY, PREFS_SCORES);  
    addHelper(MY_PREFS_BACKUP_KEY, helper);  
}  
</code></pre>

<p>}
```
你可以根据你的喜好增加许多备份帮助类, 但是请记住你仅仅需要为每一类添加一个既可。一个FileBackupHelper 处理了所有的你想要备份的文件, 一个SharedPreferencesBackupHelper 则处理了所有的你想要备份的shared preference groups.</p>

<h2>(4)Request a Backup[请求一个备份]</h2>

<p>为了请求一个备份，仅仅需要创建一个BackupManager的实例，然后调用它的dataChanged() 方法既可。
```java
import android.app.backup.BackupManager;<br/>
 ...</p>

<p>public void requestBackup() {<br/>
   BackupManager bm = new BackupManager(this);<br/>
   bm.dataChanged();<br/>
}
```</p>

<p>执行这个调用通知了backup manager 即将有数据会被备份到云端。在之后的某个时间点，backup manager会执行备份代理的 onBackup() 方法。无论任何时候，只要你的数据有发生改变的都可以去调用它，不用担心会导致过度的网络活动。如果你在上一个备份还没有发生之前再次请求了备份，那么这个备份操作仅仅会出现一次。</p>

<h2>(5)Restore from a Backup[从备份中恢复]</h2>

<p>通常是，你不应该手动去请求一个恢复，而是应该在你的程序安装到设备上的时候自动进行恢复。然而，如果那确实有必要手动去触发恢复，只需要调 requestRestore() 方法.</p>

<hr />

<p><strong>学习自：<a href="http://developer.android.com/training/cloudsync/backupapi.html">http://developer.android.com/training/cloudsync/backupapi.html</a>，请多指教，谢谢！</strong><br/>
<strong>转载请注明出自<a href="http://kesenhoo.github.com">http://kesenhoo.github.com</a>，谢谢配合！</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Training[Cloud] - 云同步(Lesson 1 - 使用App Engine进行同步)]]></title>
    <link href="http://hukai.me/blog/2012/04/22/android-training-cloud-syncing-to-the-cloud-lesson-1/"/>
    <updated>2012-04-22T13:56:00+08:00</updated>
    <id>http://hukai.me/blog/2012/04/22/android-training-cloud-syncing-to-the-cloud-lesson-1</id>
    <content type="html"><![CDATA[<h2>Syncing with App Engine[使用App Engine进行同步]</h2>

<p>写一个能够同步到云端的app是具有挑战性的。那存在许多细节需要处理，例如服务端身份验证，客户端身份验证，分享数据的模块，还有API。简化这些操作的一个方法是使用<strong>Google Plugin for Eclipse</strong>，这个插件帮你垂直整合处理了那些Android系统与App Engine程序交互的操作。这一课会介绍如何创建那样一个项目。</p>

<p>关于App Engine，请参考：https://developers.google.com/appengine/docs/whatisgoogleappengine?hl=zh-CN</p>

<p>下面会介绍:  <br/>
* 建立Android与App engine apps能够交互的程序。<br/>
* 利用Cloud to Device Messaging(C2DM)的优势，这样app就不需要使用轮询机制去更新。[关于C2DM的详情请参考前面课程与http://code.google.com/intl/zh-CN/android/c2dm/)]</p>

<!-- More -->


<p>这一课仅仅专注于本地开发测试使用，并不涉及程序发布(例如，发布你的App Engine，发布你的Android程序到Market)，程序发布等知识点会在其他课程里涉及到。</p>

<h2>(1)Prepare Your Environment[准备你的开发环境]</h2>

<p>如果你想继续下面的课程步骤，你必须依据下面所述搭建好你的开发环境:  <br/>
* 安装<a href="http://code.google.com/eclipse/">Google Plugin for Eclipse</a><br/>
* 安装<a href="http://code.google.com/webtoolkit/download.html">GWT SDK</a> 与 <a href="http://code.google.com/appengine/">Java App Engine SDK</a>. The <a href="http://code.google.com/eclipse/docs/getting_started.html">Quick Start Guide</a>会演示如何安装那些组件.<br/>
* 注册<a href="http://code.google.com/android/c2dm/signup.html">C2DM access</a>账户. 我们强烈推荐<a href="https://accounts.google.com/SignUp">creating a new Google account</a>来专门用来连接到C2DM. 在这一课Google服务器会重复使用这个账户来进行身份鉴定。</p>

<h2>(2)Create Your Projects[创建你的项目]</h2>

<p>在你安装完Google Plugin for Eclipse之后，请注意在创建一个新的Eclipse项目的时候会存在一种新的Android项目选项：<code>App Engine Connected Android Project</code>(在Google项目分类下)。安装向导会提示你输入账户验证信息，这个账户就是之前提到的你在C2DM上注册的时候使用的。(请注意不要输错了账户类型)</p>

<p>一旦你创建好之后，你会在workspace看见两个有2个项目：一个Android程序与一个App Engine程序。好吧！那两个程序具备了需要实现的所有功能，安装向导创建了sample程序，它可以允许你使用AccountManager来验证Android设备与App Engine的交互。为了便于后续测试，请做下面的操作：</p>

<p>请确保你存在2.2以上的AVD,右击Eclipse中的Android项目，选择<code>Debug As</code>><code>Local App Engine Connected Android Application</code>。这样程序就能够测试C2DM的功能(Google Play是这一类程序的典型代表).它也启动了一个App Engine的local instance，里面包含了你的程序。</p>

<h2>(3)Create the Data Layer[创建数据层]</h2>

<p>因为上面已经创建了一个完整功能的sample程序。下面应该学习开始修改那些代码来创建你自己的程序。
首先，创建数据模块，它定义了在App Engine与Android app之间共享的数据。打开App Engine项目的文件夹，定位到 <code>(yourApp)</code>-<code>AppEngine</code> > <code>src</code> > <code>(yourapp)</code> > <code>server</code>。创建一个新的类，它包含了那些你想要存储到云端的数据。下面是一段sample code:
```java
package com.cloudtasks.server;</p>

<p>import javax.persistence.*;</p>

<p>@Entity<br/>
public class Task {</p>

<pre><code>private String emailAddress;  
private String name;  
private String userId;  
private String note;  

@Id  
@GeneratedValue(strategy = GenerationType.IDENTITY)  
private Long id;  

public Task() {  
}  

public String getEmailAddress() {  
    return this.emailAddress;  
}  

public Long getId() {  
    return this.id;  
}  
...  
</code></pre>

<p>}
<code>``  
请注意注释的使用：Entity, Id 与GeneratedValue 都是来自[Java Persistence API](http://www.oracle.com/technetwork/articles/javaee/jpa-137156.html). 这些注释都是必备的， Entity需要注释在类声明的上面， 这表明这个类在你的数据层代表了一个</code>Entity.Id<code>与</code>GeneratedValue<code>分别表明了寻找这个类的id与这个id是如何形成的(在上面的示例中，</code>GenerationType.IDENTITY`意味这是由DB生成的). 你可以参考<a href="http://code.google.com/appengine/docs/java/datastore/jpa/overview.html">Using JPA with App Engine</a>来查看更多关于资料。</p>

<p>一旦你完成了所有的数据实体类的创建, 你需要创建Android与App Engine程序之间交互的方法. 这种交互的方法可以通过创建一个<code>Remote Procedure Call (RPC)</code>服务来开启。通常的是，这包含了许多一成不变的单调的代码. 幸运的是, 有一种简单的办法来完成这个操作! 在你的App Engine源代码文件夹下右击，选择<code>New</code> > <code>Other</code> ，再选择<code>Google</code> > <code>RPC Service</code>. 这个时候会出现向导, 陈列出所有你在上一步骤创建的实例,它是通过在源代码文件夹中去查找具有<code>@Entity</code>的方法来实现的. 这样出来的代码非常整洁，之后点击Finish,向导会创建一个Service类，它包含了<code>Create</code>, <code>Retrieve</code>, <code>Update</code> and <code>Delete</code> (CRUD)实例的操作.</p>

<h2>(4)Create the Persistence Layer [创建持久层]</h2>

<p>持久层是一个你的程序数据能够存放long-term的地方。为了编写你的持久层，你有一些选择，这取决于你想存储哪些类型的数据. 一些由Google管理的选择包含在<a href="http://code.google.com/apis/storage/">Google Storage for Developers</a>与App Engine's built-in Datastore. 下面是一个sample code，使用DataStore的代码.</p>

<p>在你的com.cloudtasks.server下创建一个类用来处理持久层的输入与输出. 为了访问这些数据，使用<a href="http://db.apache.org/jdo/api20/apidocs/javax/jdo/PersistenceManager.html">PersistenceManager</a>. 你可以使用在com.google.android.c2dm.server.PMF下的PMF类生成这个类的的一个实例，然后使用它来执行基本的CRUD操作:
```java
/<em>*
* Remove this object from the data store.
</em>/<br/>
public void delete(Long id) {</p>

<pre><code>PersistenceManager pm = PMF.get().getPersistenceManager();  
try {  
    Task item = pm.getObjectById(Task.class, id);  
    pm.deletePersistent(item);  
} finally {  
    pm.close();  
}  
</code></pre>

<p>}
<code>  
你也可以使用Query对象从你的Datastore来retrieve数据。
</code>java
public Task find(Long id) {</p>

<pre><code>if (id == null) {  
    return null;  
}  

PersistenceManager pm = PMF.get().getPersistenceManager();  
try {  
    Query query = pm.newQuery("select from " + Task.class.getName()  
    + " where id==" + id.toString() + " &amp;&amp; emailAddress=='" + getUserEmail() + "'");  
    List list = (List) query.execute();  
    return list.size() == 0 ? null : list.get(0);  
} catch (RuntimeException e) {  
    System.out.println(e);  
    throw e;  
} finally {  
    pm.close();  
}  
</code></pre>

<p>}
```<br/>
一个好的例子，帮你encapsulate了持久层，请参考Cloud Tasks app里面的DataStore类.</p>

<h2>(5)Query and Update from the Android App [从Android App查询与更新]</h2>

<p>为了保持与App Engine程序的同步，你的Android程序需要知道下面两件事情：从云端拉取数据与发送数据到云端。大部分这类操作已经由上面提到的插件生成了，但是你需要自己编写UI来呈现那些操作.</p>

<p>插件生成的sample code显示了一些重要的特征：<br/>
* 首先，我们需要删除样本里面的Activity.java中的setHelloWorldScreenContent()的方法，替换的是与实际程序有关的代码。<br/>
* 其次，所有交互的操作都是包在AsyncTask中来完成的，这样不会因为网络操作而卡到UI thread.<br/>
* 最后，它给出了一个简单的模板演示如何访问云端的数据, 使用RequestFactory 来操作，它由Eclipse plugin提供支持。</p>

<p>关于实例，如果你的云端数据模型包含了一个叫做Task的对象，这个对象会在你生成RPC layer的时候自动为你创建的一个TaskRequest的类, 还有一个TaskProxy来代表单独的Task. 在下面的代码中演示了请求一个所有task的列表:
```java
public void fetchTasks (Long id) {<br/>
  // Request is wrapped in an AsyncTask to avoid making a network request<br/>
  // on the UI thread.</p>

<pre><code>new AsyncTask&gt;() {  
    @Override  
    protected List doInBackground(Long... arguments) {  
        final List list = new ArrayList();  
        MyRequestFactory factory = Util.getRequestFactory(mContext,  
        MyRequestFactory.class);  
        TaskRequest taskRequest = factory.taskNinjaRequest();  

        if (arguments.length == 0 || arguments[0] == -1) {  
            factory.taskRequest().queryTasks().fire(new Receiver&gt;() {  
                @Override  
                public void onSuccess(List arg0) {  
                  list.addAll(arg0);  
                }  
            });  
        } else {  
            newTask = true;  
            factory.taskRequest().readTask(arguments[0]).fire(new Receiver() {  
                @Override  
                public void onSuccess(TaskProxy arg0) {  
                  list.add(arg0);  
                }  
            });  
        }  
    return list;  
}  

@Override  
protected void onPostExecute(List result) {  
    TaskNinjaActivity.this.dump(result);  
}  

}.execute(id);  
</code></pre>

<p>}<br/>
...</p>

<p>public void dump (List tasks) {</p>

<pre><code>for (TaskProxy task : tasks) {  
    Log.i("Task output", task.getName() + "\n" + task.getNote());  
}  
</code></pre>

<p>}
<code>  
为了创建一个新的任务并发送到云端，需要创建一个新的请求对象并使用它来创建一个proxy对象。然后proxy对象执行它的更新方法。重申，这些操作应该放在AsyncTask里面去执行，避免网络操作卡到UI Thread。下面是sample code:
</code>java
new AsyncTask() {</p>

<pre><code>@Override  
protected Void doInBackground(Void... arg0) {  
    MyRequestFactory factory = (MyRequestFactory)  
            Util.getRequestFactory(TasksActivity.this,  
            MyRequestFactory.class);  
    TaskRequest request = factory.taskRequest();  

    // Create your local proxy object, populate it  
    TaskProxy task = request.create(TaskProxy.class);  
    task.setName(taskName);  
    task.setNote(taskDetails);  
    task.setDueDate(dueDate);  

    // To the cloud!  
    request.updateTask(task).fire();  
    return null;  
}  
</code></pre>

<p>}.execute();
```</p>

<h2>(6)Configure the C2DM Server-Side[确认C2DM服务器端]</h2>

<p>为了设置C2DM的消息能够被发送到你的Android设备，回到你的App Engine代码处，打开生成RPC层的时候创建的Service类. 如果你的项目名是Foo, 这个类的名字就叫做FooService. 为每一个方法都添加一些代码，允许做adding, deleting, or updating数据的操作，这样C2DM message才能发送到用户的设备上. 下面是一段sample code:
```java
public static Task updateTask(Task task) {</p>

<pre><code>task.setEmailAddress(DataStore.getUserEmail());  
task = db.update(task);  
DataStore.sendC2DMUpdate(TaskChange.UPDATE + TaskChange.SEPARATOR + task.getId());  
return task;  
</code></pre>

<p>}</p>

<p>// Helper method.  Given a String, send it to the current user's device via C2DM.<br/>
public static void sendC2DMUpdate(String message) {</p>

<pre><code>UserService userService = UserServiceFactory.getUserService();  
User user = userService.getCurrentUser();  
ServletContext context = RequestFactoryServlet.getThreadLocalRequest().getSession().getServletContext();  
SendMessage.sendMessage(context, user.getEmail(), message);  
</code></pre>

<p>}
<code>  
在下面的示例中，一个帮助类TaskChange，创建了一些常量. 这样一个帮助类能够使得App Engine与Android App直接的交互更简单。
</code>java
public class TaskChange {</p>

<pre><code>public static String UPDATE = "Update";  
public static String DELETE = "Delete";  
public static String SEPARATOR = ":";  
</code></pre>

<p>}</p>

<h2>(7)Configure the C2DM Client-Side [确认C2DM的客户端]</h2>

<p>为了定义Android程序在接受到C2DM的消息的行为，打开C2DMReceiver类, 找到onMessage() 方法. 根据接受到的消息类型进行修改这个方法.
```java
//In your C2DMReceiver class</p>

<p>public void notifyListener(Intent intent) {</p>

<pre><code>if (listener != null) {  
    Bundle extras = intent.getExtras();  
    if (extras != null) {  
        String message = (String) extras.get("message");  
        String[] messages = message.split(Pattern.quote(TaskChange.SEPARATOR));  
        listener.onTaskUpdated(messages[0], Long.parseLong(messages[1]));  
    }  
}  
</code></pre>

<p>}<br/>
// Elsewhere in your code, wherever it makes sense to perform local updates<br/>
public void onTasksUpdated(String messageType, Long id) {</p>

<pre><code>if (messageType.equals(TaskChange.DELETE)) {  
    // Delete this task from your local data store  
    ...  
} else {  
    // Call that monstrous Asynctask defined earlier.  
    fetchTasks(id);  
}  
</code></pre>

<p>}
```<br/>
一旦C2DM消息触发了本地进行更新，那么说明已经设置成功。</p>

<p><strong>Ps:不知何故，官方后来移除了这篇文章，原有的<a href="http://developer.android.com/training/cloudsync/aesync.html">链接</a>)已经失效,云备份我也一直没有接触过，上面的例子也没有自己实践过，当作是知识储备了，大家也可以参考学习下。</strong></p>

<hr />

<p><strong>转载请注明出自<a href="http://kesenhoo.github.com">http://kesenhoo.github.com</a>，谢谢配合！</strong></p>
]]></content>
  </entry>
  
</feed>
