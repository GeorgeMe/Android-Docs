<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android:Notes | 胡凯]]></title>
  <link href="http://hukai.me/blog/categories/android-notes/atom.xml" rel="self"/>
  <link href="http://hukai.me/"/>
  <updated>2014-08-17T17:06:04+08:00</updated>
  <id>http://hukai.me/</id>
  <author>
    <name><![CDATA[Kesen Hoo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android Notes - 添加Copy to Clipboard的选项到分享列表中]]></title>
    <link href="http://hukai.me/blog/android-notes-add-copy-text-option-to-share-list/"/>
    <updated>2014-07-12T15:26:00+08:00</updated>
    <id>http://hukai.me/blog/android-notes-add-copy-text-option-to-share-list</id>
    <content type="html"><![CDATA[<p>偶然被人问到如何添加复制到剪切板的选项到分享列表，如下图所示：</p>

<p><img src="/images/copy_link_option_at_share_list.png" alt="copy_link_option_at_share_list" /></p>

<p>一般情况下，分享一段文字或者图片，我们会使用如下Android默认的方式：</p>

<p>```java
public void shareText(Context context, String text) {</p>

<pre><code>Intent sendIntent = new Intent();
sendIntent.setAction(Intent.ACTION_SEND);
sendIntent.putExtra(Intent.EXTRA_TEXT, text);
sendIntent.setType("text/plain");
context.startActivity(Intent.createChooser(sendIntent, "Share via..."));
</code></pre>

<p>}
```</p>

<p>这样系统能够帮忙筛选出那些符合这个Intent的所有Activity，生成分享列表，呈现给用户。因为分享列表的信息是由系统过滤生成的，UI界面也是交给系统进行绘制的，我们的应用无法给这个分享列表设置点击监听器，那么如何才能实现添加一个<strong>"Copy to Clipboard"</strong>的选项到分享列表中，并在点击该选项之后执行对应的动作呢？当然，自己去实现这个分享列表的效果，UI完全交给自己的应用来控制，是可以轻松做到的，可是自己去过滤符合条件的应用，并绘制分享列表的代码量会大很多，实现起来更加复杂？下面介绍一个虽然写法有点奇怪却相对简便很多的方法。</p>

<!-- More -->


<p>实现步骤如下：</p>

<h3>1)创建一个新的Intent</h3>

<p>```java
Intent intent = new Intent(Intent.ACTION_SEND);
intent.setType("text/plain");
intent.putExtra(Intent.EXTRA_SUBJECT, title);
intent.putExtra(Intent.EXTRA_TEXT, body);</p>

<p>Intent clipboardIntent = new Intent("ACTION_COPY_TO_CLIPBOARD");
clipboardIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
clipboardIntent.putExtra("KEY_SHARE_TITLE", title);
clipboardIntent.putExtra("KEY_SHARE_BODY", body);</p>

<p>try {</p>

<pre><code>Intent chooserIntent = Intent.createChooser(intent, "Share via");
chooserIntent.putExtra(Intent.EXTRA_INITIAL_INTENTS, new Intent[] {clipboardIntent});
context.startActivity(chooserIntent);
</code></pre>

<p>} catch (android.content.ActivityNotFoundException ex) {</p>

<pre><code>Toast.makeText(context, "There are no share clients installed.", Toast.LENGTH_SHORT).show();
</code></pre>

<p>}
```</p>

<p>请注意：Action与Flag。</p>

<h3>2)在manifest文件中为当前的actiivty添加Intent Filter</h3>

<p>```xml
&lt;activity</p>

<pre><code>android:name=".TestActivity"
android:label="Copy to clipboard"
android:icon="@drawable/ic_action_copy"
android:launchMode="singleTop"
android:screenOrientation="portrait"
android:windowSoftInputMode="adjustPan"&gt;
&lt;intent-filter&gt;
    &lt;action android:name="ACTION_COPY_TO_CLIPBOARD"/&gt;
    &lt;category android:name="android.intent.category.DEFAULT"/&gt;
&lt;/intent-filter&gt;
</code></pre>

<p></activity>
```</p>

<p>icon与label组成了分享列表中的"复制到剪切板"。launchMode定义为singleTop是因为当前activity已经在栈顶，没有必要因为intent的到来而重新创建一个，所以维持目前的activity，使得点击”复制到剪切板“之后，activity会直接执行onNewIntent()的回调，在这里获取到之前定义的intent，从这个intent获取后续操作的数据。</p>

<h3>3)在onNewIntent()中执行把文字复制到剪切板的任务</h3>

<p>```java
@Override
protected void onNewIntent(Intent intent) {</p>

<pre><code>super.onNewIntent(intent);
Log.i(TAG, "[onNewIntent] intent = " + intent);
if (intent != null &amp;&amp; intent.getAction().equalsIgnoreCase("ACTION_COPY_TO_CLIPBOARD")) {
    String title = intent.getStringExtra("KEY_SHARE_TITLE");
    String body = intent.getStringExtra("KEY_SHARE_BODY");

    ClipboardManager clipboard = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);
    // clipboard.setText(title + body);
    // Creates a new text clip to put on the clipboard
    ClipData clip = ClipData.newPlainText(title, body);
    clipboard.setPrimaryClip(clip);
    Log.d(TAG, "[onNewIntent] copy text title = " + title + ", body = " + body);
    Toast.makeText(this, "Copy Succussed!", Toast.LENGTH_SHORT).show();
}
</code></pre>

<p>}
```</p>

<hr />

<p>至此，这个功能就实现了，这种写法还给了我们更多的启发：可以使用类似的方式添加其他的选项到分享列表中，在activity的onNewIntent回调里面处理这个选项要求实现的任务。这种方式相比起自己去过滤并绘制分享列表要简单很多！欢迎有其他实现方法的同学留言交流！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Notes(06) - Camera]]></title>
    <link href="http://hukai.me/blog/android-notes-camera/"/>
    <updated>2014-04-21T21:24:00+08:00</updated>
    <id>http://hukai.me/blog/android-notes-camera</id>
    <content type="html"><![CDATA[<p>Android framework为各种不同的Camera与Camera的特色功能提供了支持，使得可以在应用中进行拍照与录像。这篇文章会讨论一种简便，快速的拍照录像方式，为了给用户创建定制的相机体验，文章也会概述相机的高级功能。</p>

<h2>0)开始之前</h2>

<p>在应用中开启Android设备的相机功能之前，应该考量如下几个问题：</p>

<ul>
<li><strong>必须的相机硬件</strong> - 当然不能把一个包含相机功能的应用安装到一个连相机硬件都没有的设备上。因此，应该在mainfest文件中声明需要使用到相机。</li>
<li><strong>快速获取图片还是定制相机</strong> - 应用将如何使用相机？是想做一个快速的抓拍还是录制一小段视频剪辑？还是说想提供一种新的相机使用方式？如果是快速的获取一张抓拍图片或者是一小段视频剪辑，建议查看下面的<strong>3)使用已经安装的相机应用。</strong>如果是为了开发一个定制相机功能的应用，查看下面的<strong>4)创建一个相机应用</strong>。</li>
<li><strong>存储位置</strong> - 生成的图片与视频是只对自己的应用可见还是其它类似Gallery的应用也可以访问？即使自己的应用被卸载后也不能被其他应用访问吗？建议查看<strong>5)保存媒体文件</strong></li>
</ul>


<h2>1)简要概述</h2>

<p>Android framework通过提供Camera API来支持拍照与录制视频的功能。下面是相关的类：</p>

<ul>
<li><a href="http://developer.android.com/reference/android/hardware/Camera.html"><strong>Camera</strong></a><br/>
该类是控制相机硬件的基础的API。它可以用来拍照或者录制视频。</li>
<li><a href="http://developer.android.com/reference/android/view/SurfaceView.html"><strong>SurfaceView</strong></a><br/>
该类是用来呈现一个动态的相机预览界面。</li>
<li><a href="http://developer.android.com/reference/android/media/MediaRecorder.html"><strong>MediaRecorder</strong></a><br/>
该类用来使用相机录制视频。</li>
<li><a href="http://developer.android.com/reference/android/content/Intent.html"><strong>Intent</strong></a><br/>
使用<a href="http://developer.android.com/reference/android/provider/MediaStore.html#ACTION_IMAGE_CAPTURE">MediaStore.ACTION_IMAGE_CAPTURE</a> 或者 <a href="http://developer.android.com/reference/android/provider/MediaStore.html#ACTION_VIDEO_CAPTURE">MediaStore.ACTION_VIDEO_CAPTURE</a>作为Intent的action可以用来拍照与录制视频。</li>
</ul>


<!-- More -->


<h2>2)Manifest声明</h2>

<p>在使用Camera API开发应用之前，应该确保应用的mainfest中有做恰当的声明，表明需要使用相机或者是相机的相关功能。</p>

<ul>
<li><p><strong>Camera Permission</strong> - 为了使用相机硬件，你的应用必须请求使用Camera的权限。<br/>
<code>xml
&lt;uses-permission android:name="android.permission.CAMERA" /&gt;
</code><br/>
<strong>Note:</strong>如果你是通过Intent来使用Camera，你的应用程序则不需要请求这个权限。</p></li>
<li><p><strong>Camera Features</strong> - 你的应用还必须声明使用相机功能，例如：<br/>
<code>xml
&lt;uses-feature android:name="android.hardware.camera" /&gt;
</code><br/>
关于相机功能列表，请参考<a href="http://developer.android.com/guide/topics/manifest/uses-feature-element.html#hw-features">功能引用</a>。增加相机功能到你的mainfest文件，这样Google Play可以阻止那些没有相机硬件或者没有相机特定功能的设备安装你的应用。关于Google Play如何做过滤的信息，请参考<a href="http://developer.android.com/guide/topics/manifest/uses-feature-element.html#market-feature-filtering">Google Play and Feature-Based Filtering</a>。<br/>
你还可以为每个相机特性设置<code>android:required</code>的属性，表示这个功能是否为必须的。</p></li>
<li><p><strong>Storage Permission</strong> - 如果你的应用需要保存图片或者视频到设备的外置存储空间(SD card)上，你也需要在manifest中指定存取权限。<br/>
<code>xml
&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;
</code></p></li>
<li><p><strong>Audio Recording Permission</strong> - 为了录制音频或者视频，你的程序必须请求audio capture permission。<br/>
<code>xml
&lt;uses-permission android:name="android.permission.RECORD_AUDIO" /&gt;
</code></p></li>
<li><strong>Location Permission</strong> - 如果你的应用需要为图片添加位置信息，你还需要请求location permission:<br/>
<code>xml
&lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt;
</code><br/>
关于获取用户位置信息的更多细节，请参考<a href="http://developer.android.com/guide/topics/location/strategies.html">Location Strategies</a>.</li>
</ul>


<h2>3)Using Existing Camera Apps</h2>

<p>在你的应用中快速的实现拍照与录制视频的方法是使用一个Intent来调用已经存在系统中的相机程序。通过已经存在的相机程序拍照或者录制视频，然后返回数据给请求方。这一部分会演示如何使用这种技术。</p>

<p>触发Camera Intent需要遵守如下几个步骤：</p>

<ul>
<li><p><strong>Compose a Camera Intent</strong> - 创建一个请求拍照或者录像的Intent，使用下面的intent类型：</p>

<ul>
<li><a href="http://developer.android.com/reference/android/provider/MediaStore.html#ACTION_IMAGE_CAPTURE">MediaStore.ACTION_IMAGE_CAPTURE</a> - 请求拍照的Intent。</li>
<li><a href="http://developer.android.com/reference/android/provider/MediaStore.html#ACTION_VIDEO_CAPTURE">MediaStore.ACTION_VIDEO_CAPTURE</a> - 请求录像的Intent。</li>
</ul>
</li>
<li><p><strong>Start the Camera Intent</strong> - 使用<a href="http://developer.android.com/reference/android/app/Activity.html#startActivityForResult(android.content.Intent,%20int">startActivityForResult()</a>)方法来执行这个Intent。在启动这个Intent之后，相机程序会被唤起并提供拍照或者录像的功能。</p></li>
<li><p><strong>Receive the Intent Result</strong> - 在你的程序里面实现<a href="http://developer.android.com/reference/android/app/Activity.html#onActivityResult(int,%20int,%20android.content.Intent">onActivityResult()</a>)的方法用来接收相机程序返回的数据。当用户结束拍照或者录像之后，系统会调用到这个方法。</p></li>
</ul>


<h3>3.1)Image capture intent</h3>

<p>使用Camera Intent是一种使用最少的代码为你的程序开启拍照功能的一种简便的方法。一个拍照程序可以包含下面的附加信息：</p>

<p><strong><a href="http://developer.android.com/reference/android/provider/MediaStore.html#EXTRA_OUTPUT">MediaStore.EXTRA_OUTPUT</a></strong> - 这定义了一个Uri对象来指定存放图片的路径与文件名。这个设置信息是可选的，但是强烈建议添加。如果你不指定这个值，相机程序会使用默认的文件名保存图片到默认的位置，这个值可以从Intent.getData()的字段中获取到。</p>

<p>下面的示例代码演示了如何构建一个拍照Intent并执行它。<code>getOutputMediaFileUri()</code>方法可以从<strong>Saving Media Files</strong>的段落中涉及到。</p>

<p>```java
private static final int CAPTURE_IMAGE_ACTIVITY_REQUEST_CODE = 100;
private Uri fileUri;</p>

<p>@Override
public void onCreate(Bundle savedInstanceState) {</p>

<pre><code>super.onCreate(savedInstanceState);
setContentView(R.layout.main);

// create Intent to take a picture and return control to the calling application
Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);

fileUri = getOutputMediaFileUri(MEDIA_TYPE_IMAGE); // create a file to save the image
intent.putExtra(MediaStore.EXTRA_OUTPUT, fileUri); // set the image file name

// start the image capture Intent
startActivityForResult(intent, CAPTURE_IMAGE_ACTIVITY_REQUEST_CODE);
</code></pre>

<p>}
```</p>

<p>当startActivityForResult()方法被执行，用户会看到一个相机拍照的界面。用户执行了拍照(或者取消操作)，用户界面会回退到你的程序，你必须在onActivityResult()方法里面接收返回的数据。关于如何接受完整的intent，可以参考下面的<strong>Receiving camera intent result</strong>段落。</p>

<h3>3.2)Video capture intent</h3>

<p>视频录制的原理和拍照一致。一个视频录制的Intent可以包含如下的参数信息：</p>

<ul>
<li><a href="http://developer.android.com/reference/android/provider/MediaStore.html#EXTRA_OUTPUT">MediaStore.EXTRA_OUTPUT</a> - 和拍照类似，这里指定保存视频的位置。同样这个字段是可选的，但是也被强烈建议进行填写。如果没有传递这个参数，相机程序会使用默认的文件名保存文件到默认的存储位置。你可以通过在返回的Intent.getData()字段中获取到这个值。</li>
<li><a href="http://developer.android.com/reference/android/provider/MediaStore.html#EXTRA_VIDEO_QUALITY">MediaStore.EXTRA_VIDEO_QUALITY</a> - 这里的值可以为0或者1，分别表示低质量与高质量。</li>
<li><a href="http://developer.android.com/reference/android/provider/MediaStore.html#EXTRA_DURATION_LIMIT">MediaStore.EXTRA_DURATION_LIMIT</a> - 设置这个值用来限制视频的长度，用毫秒计算。</li>
<li><a href="http://developer.android.com/reference/android/provider/MediaStore.html#EXTRA_SIZE_LIMIT">MediaStore.EXTRA_SIZE_LIMIT</a> - 设置这个值用来限制文件的大小，用btye做单位。</li>
</ul>


<p>下面演示了如何构建一个Video Intent并执行：
```java
private static final int CAPTURE_VIDEO_ACTIVITY_REQUEST_CODE = 200;
private Uri fileUri;</p>

<p>@Override
public void onCreate(Bundle savedInstanceState) {</p>

<pre><code>super.onCreate(savedInstanceState);
setContentView(R.layout.main);

//create new Intent
Intent intent = new Intent(MediaStore.ACTION_VIDEO_CAPTURE);

fileUri = getOutputMediaFileUri(MEDIA_TYPE_VIDEO);  // create a file to save the video
intent.putExtra(MediaStore.EXTRA_OUTPUT, fileUri);  // set the image file name

intent.putExtra(MediaStore.EXTRA_VIDEO_QUALITY, 1); // set the video image quality to high

// start the Video Capture Intent
startActivityForResult(intent, CAPTURE_VIDEO_ACTIVITY_REQUEST_CODE);
</code></pre>

<p>}
```
和拍照类似，也需要在activity的onActivityResult里面去接收数据并做处理。</p>

<h3>3.3)Receiving camera intent result</h3>

<p>一旦你构建并执行了一个拍照或者录像的Intent，你的程序必须确保能够正确接收返回的数据。为了正确的接收到Intent，你必须重写onActivityResult()的方法，下面会演示如何获取到上面示例代码返回的数据。</p>

<p>```java
private static final int CAPTURE_IMAGE_ACTIVITY_REQUEST_CODE = 100;
private static final int CAPTURE_VIDEO_ACTIVITY_REQUEST_CODE = 200;</p>

<p>@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {</p>

<pre><code>if (requestCode == CAPTURE_IMAGE_ACTIVITY_REQUEST_CODE) {
    if (resultCode == RESULT_OK) {
        // Image captured and saved to fileUri specified in the Intent
        Toast.makeText(this, "Image saved to:\n" +
                 data.getData(), Toast.LENGTH_LONG).show();
    } else if (resultCode == RESULT_CANCELED) {
        // User cancelled the image capture
    } else {
        // Image capture failed, advise user
    }
}

if (requestCode == CAPTURE_VIDEO_ACTIVITY_REQUEST_CODE) {
    if (resultCode == RESULT_OK) {
        // Video captured and saved to fileUri specified in the Intent
        Toast.makeText(this, "Video saved to:\n" +
                 data.getData(), Toast.LENGTH_LONG).show();
    } else if (resultCode == RESULT_CANCELED) {
        // User cancelled the video capture
    } else {
        // Video capture failed, advise user
    }
}
</code></pre>

<p>}
```</p>

<p>一旦你的activity成功接收了数据，那么你的程序就可以在指定的位置获取到图片或者视频了。</p>

<h2>4)Building a Camera App</h2>

<p>一些开发者也许需要开发一个定制的相机应用，用来提供特殊的功能与体验。创建一个定制的相机界面比起使用Intent需要更多的代码，但是它能够提供一种更加优秀的用户体验。</p>

<p>通常来说创建一个定制化的相机界面有如下几个步骤：</p>

<ul>
<li><strong>Detect and Access Camera</strong> - 检查相机是否存在并可访问。</li>
<li><strong>Create a Preview Class</strong> - 创建一个继承自SurfaceView的preview类，并implement SurfaceHolder的接口的interface。这个类用来预览相机的动态图片。</li>
<li><strong>Build a Preview Layout</strong> - 一旦你拥有了preview class。创建一个Layout用来承载preview并提供交互控制界面。</li>
<li><strong>Setup Listeners for Capture</strong> - 为控制界面建立监听器，用来启动拍照或者录像。</li>
<li><strong>Capture and Save Files</strong> - 建立拍照录像的代码并进行保存。</li>
<li><strong>Release the Camera</strong> - 使用完相机之后，你的程序必须正确的释放它，以便其他程序使用。</li>
</ul>


<p>相机硬件是一个共享资源，它必须被小心谨慎的管理使用。因此你的程序不应该和其他可能使用相机硬件的程序有冲突。下面的段落会介绍如何检测相机硬件，如何请求获取权限，如何拍照录像以及如何在使用完毕时释放相机。</p>

<p><strong>注意:</strong> 当你的程序执行完任务之后，需要记得通过执行Camera.release()来释放相机对象。如果你的相机没有合理的释放相机，后续包括你自己的应用在内的所有的相机应用，都将无法正常打开相机并且可能导致程序崩溃。</p>

<h3>4.1)Detecting camera hardware</h3>

<p>如果你的程序没有在manifest中声明需要使用相机，你应该在运行时去检查相机是否可用。为了执行这个检查，需要使用到<a href="http://developer.android.com/reference/android/content/pm/PackageManager.html#hasSystemFeature(java.lang.String">PackageManager.hasSystemFeature()</a>) 方法，如下所示：</p>

<p>```java
/<em>* Check if this device has a camera </em>/
private boolean checkCameraHardware(Context context) {</p>

<pre><code>if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_CAMERA)){
    // this device has a camera
    return true;
} else {
    // no camera on this device
    return false;
}
</code></pre>

<p>}
```</p>

<p>Android设备可以拥有多个摄像头，例如前置与后置摄像头。从Android 2.3 (API Level 9)开始，可以通过<a href="http://developer.android.com/reference/android/hardware/Camera.html#getNumberOfCameras(">Camera.getNumberOfCameras()</a>)方法获取到摄像头的个数。</p>

<h3>4.2)Accessing cameras</h3>

<p>如果你已经判断到程序运行的设备上有摄像头，你需要获取到摄像头的话，需要通过一个相机实例来进行访问。</p>

<p>为了访问到主摄像头，如下所示，使用<a href="http://developer.android.com/reference/android/hardware/Camera.html#open(">Camera.open()</a>)方法。
```java
/<em>* A safe way to get an instance of the Camera object. </em>/
public static Camera getCameraInstance(){</p>

<pre><code>Camera c = null;
try {
    c = Camera.open(); // attempt to get a Camera instance
}
catch (Exception e){
    // Camera is not available (in use or does not exist)
}
return c; // returns null if camera is unavailable
</code></pre>

<p>}
```</p>

<p><strong>注意:</strong> 当使用Camera.open方法时总是需要做检查exceptions的动作。如果没有检查exception，有可能会因为相机正在使用或者相机不存在而使得程序崩溃。</p>

<p>在Android 2.3 (API Level 9)开始, 你可以使用通过<a href="http://developer.android.com/reference/android/hardware/Camera.html#open(int">Camera.open(int)</a>)方法来访问特定的摄像头。上面演示的代码会优先获取主摄像头。</p>

<h3>4.3)Checking camera features</h3>

<p>一旦你获取到相机，你可以使用<a href="http://developer.android.com/reference/android/hardware/Camera.html#getParameters(">Camera.getParameters()</a>)方法来获取到更多的相机信息。也可以通过获取到的相机参数对象得到相机能够支持的功能。从android 2.3开始，使用<a href="http://developer.android.com/reference/android/hardware/Camera.html#getCameraInfo(int,%20android.hardware.Camera.CameraInfo">Camera.getCameraInfo()</a>)可以获取到相机是前置还是后置摄像头以及拍摄出来的图片角度。</p>

<h3>4.4)Creating a preview class</h3>

<p>为了给用户提供有效的拍照与录像体验，用户需要能够看到摄像头捕获的数据。相机预览是使用SurfaceView，它能够显示来自摄像头的数据，因此用户可以分割捕获图片或者视频。</p>

<p>下面的示例代码演示了如何创建一个基础的相机预览类，该类可以included到另外一个layout中。为了捕获拍照事件的回调，需要implement<a href="http://developer.android.com/reference/android/view/SurfaceHolder.Callback.html">SurfaceHolder.Callback</a> ，之后可以在这些回调里面进行创建与销毁View的操作。</p>

<p>```java
/<em>* A basic Camera preview class </em>/
public class CameraPreview extends SurfaceView implements SurfaceHolder.Callback {</p>

<pre><code>private SurfaceHolder mHolder;
private Camera mCamera;

public CameraPreview(Context context, Camera camera) {
    super(context);
    mCamera = camera;

    // Install a SurfaceHolder.Callback so we get notified when the
    // underlying surface is created and destroyed.
    mHolder = getHolder();
    mHolder.addCallback(this);
    // deprecated setting, but required on Android versions prior to 3.0
    mHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
}

public void surfaceCreated(SurfaceHolder holder) {
    // The Surface has been created, now tell the camera where to draw the preview.
    try {
        mCamera.setPreviewDisplay(holder);
        mCamera.startPreview();
    } catch (IOException e) {
        Log.d(TAG, "Error setting camera preview: " + e.getMessage());
    }
}

public void surfaceDestroyed(SurfaceHolder holder) {
    // empty. Take care of releasing the Camera preview in your activity.
}

public void surfaceChanged(SurfaceHolder holder, int format, int w, int h) {
    // If your preview can change or rotate, take care of those events here.
    // Make sure to stop the preview before resizing or reformatting it.

    if (mHolder.getSurface() == null){
      // preview surface does not exist
      return;
    }

    // stop preview before making changes
    try {
        mCamera.stopPreview();
    } catch (Exception e){
      // ignore: tried to stop a non-existent preview
    }

    // set preview size and make any resize, rotate or
    // reformatting changes here

    // start preview with new settings
    try {
        mCamera.setPreviewDisplay(mHolder);
        mCamera.startPreview();

    } catch (Exception e){
        Log.d(TAG, "Error starting camera preview: " + e.getMessage());
    }
}
</code></pre>

<p>}
```</p>

<p>如果你想为你的相机预览界面设置特定的预览大小，可以在<code>surfaceChanged()</code>的回调里面进行操作(注意上面演示代码的注释)。设置预览大小时，你<strong>必须</strong>使用从<a href="http://developer.android.com/reference/android/hardware/Camera.Parameters.html#getSupportedPreviewSizes(">getSupportedPreviewSizes()</a>)方法获取到的预览值，不能在<a href="http://developer.android.com/reference/android/hardware/Camera.Parameters.html#setPreviewSize(int,%20int">setPreviewSize()</a>)方法里设置随意的预览值。</p>

<h3>4.5)Placing preview in a layout</h3>

<p>在上一段落演示的Camera Preview Class,必须放置在一个activity的layout中。这一段落会演示为了预览如何创建一个基础的layout与activity。</p>

<p>下面的代码提供了一个能够显示相机预览界面的基础layout。在这段代码中，FrameLayout是相机预览类的container。使用framelayout可以在相机预览界面上叠加额外的图片信息或者是操作控制组件。</p>

<p>```xml
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"</p>

<pre><code>android:orientation="horizontal"
android:layout_width="fill_parent"
android:layout_height="fill_parent"
&gt;
</code></pre>

<p>  &lt;FrameLayout</p>

<pre><code>android:id="@+id/camera_preview"
android:layout_width="fill_parent"
android:layout_height="fill_parent"
android:layout_weight="1"
/&gt;
</code></pre>

<p>  &lt;Button</p>

<pre><code>android:id="@+id/button_capture"
android:text="Capture"
android:layout_width="wrap_content"
android:layout_height="wrap_content"
android:layout_gravity="center"
/&gt;
</code></pre>

<p></LinearLayout>
```</p>

<p>在大多数设备上，相机预览的角度默认是横屏的。演示的layout指定了horizontal，并且下面的代码使得activity固定成横屏的模式。</p>

<p>```xml
&lt;activity android:name=".CameraActivity"</p>

<pre><code>      android:label="@string/app_name"

      android:screenOrientation="landscape"&gt;
      &lt;!-- configure this activity to use landscape orientation --&gt;

      &lt;intent-filter&gt;
    &lt;action android:name="android.intent.action.MAIN" /&gt;
    &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
&lt;/intent-filter&gt;
</code></pre>

<p></activity>
```</p>

<p><strong>Note:</strong> 相机预览界面不一定是要横屏的。从android 2.2开始，你可以使用<a href="http://developer.android.com/reference/android/hardware/Camera.html#setDisplayOrientation(int">setDisplayOrientation()</a>)方法来设置预览图片的角度。为了在用户旋转手机时改变相机预览的角度，在<code>surfaceChanged()</code>方法里面，首先要使用<a href="http://developer.android.com/reference/android/hardware/Camera.html#stopPreview(">Camera.stopPreview()</a>)停止预览，然后再使用<a href="http://developer.android.com/reference/android/hardware/Camera.html#startPreview(">Camera.startPreview()</a>)方法来重新开启相机预览。</p>

<p>为了在activity中添加相机界面，你的Camera Activity必须确保在activity pause或者是destory的时候释放相机资源。下面的代码演示了如何添加camera preview class到camera activity中。</p>

<p>```java
public class CameraActivity extends Activity {</p>

<pre><code>private Camera mCamera;
private CameraPreview mPreview;

@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.main);

    // Create an instance of Camera
    mCamera = getCameraInstance();

    // Create our Preview view and set it as the content of our activity.
    mPreview = new CameraPreview(this, mCamera);
    FrameLayout preview = (FrameLayout) findViewById(R.id.camera_preview);
    preview.addView(mPreview);
}
</code></pre>

<p>}
```</p>

<p><strong>Note:</strong> 上面演示的<code>getCameraInstance()</code>方法出现在4.2)Accessing camera段落中。</p>

<h3>4.6)Capturing pictures</h3>

<p>一旦你建立了preview class并且创建好了显示的layout。那么就可以开始做拍照的动作了。</p>

<p>为了获取到一张图片，需要使用<a href="http://developer.android.com/reference/android/hardware/Camera.html#takePicture(android.hardware.Camera.ShutterCallback,%20android.hardware.Camera.PictureCallback,%20android.hardware.Camera.PictureCallback">Camera.takePicture()</a>)方法。为了获取到JPEG格式的图片数据，你必须implement一个<a href="http://developer.android.com/reference/android/hardware/Camera.PictureCallback.html">Camera.PictureCallback</a>接口来接收图片数据并把它写到文件中。</p>

<p>```java
private PictureCallback mPicture = new PictureCallback() {</p>

<pre><code>@Override
public void onPictureTaken(byte[] data, Camera camera) {

    File pictureFile = getOutputMediaFile(MEDIA_TYPE_IMAGE);
    if (pictureFile == null){
        Log.d(TAG, "Error creating media file, check storage permissions: " +
            e.getMessage());
        return;
    }

    try {
        FileOutputStream fos = new FileOutputStream(pictureFile);
        fos.write(data);
        fos.close();
    } catch (FileNotFoundException e) {
        Log.d(TAG, "File not found: " + e.getMessage());
    } catch (IOException e) {
        Log.d(TAG, "Error accessing file: " + e.getMessage());
    }
}
</code></pre>

<p>};
```</p>

<p>触发拍照的动作，需要使用下面演示到的方法。</p>

<p>```java
// Add a listener to the Capture button
Button captureButton = (Button) findViewById(id.button_capture);
captureButton.setOnClickListener(</p>

<pre><code>new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        // get an image from the camera
        mCamera.takePicture(null, null, mPicture);
    }
}
</code></pre>

<p>);
```</p>

<h3>4.7)Capturing videos</h3>

<p>录制视频的内容，暂时跳过，下次再看。</p>

<h3>4.8)Releasing the camera</h3>

<p>相机是被共享的一种资源。获取到一个相机实例之后，程序才可以使用相机，但是，在使用完相机的时候，程序必须小心谨慎的释放它。在程序进入到pause状态时，立即释放相机资源。如果你的程序没有合理的释放相机资源，包括自己程序本身在内，后续所有的相机请求都将失败，甚至可能会导致程序崩溃。下面的代码演示了如何释放相机资源。</p>

<p>```java
public class CameraActivity extends Activity {</p>

<pre><code>private Camera mCamera;
private SurfaceView mPreview;
private MediaRecorder mMediaRecorder;

...

@Override
protected void onPause() {
    super.onPause();
    releaseMediaRecorder();       // if you are using MediaRecorder, release it first
    releaseCamera();              // release the camera immediately on pause event
}

private void releaseMediaRecorder(){
    if (mMediaRecorder != null) {
        mMediaRecorder.reset();   // clear recorder configuration
        mMediaRecorder.release(); // release the recorder object
        mMediaRecorder = null;
        mCamera.lock();           // lock camera for later use
    }
}

private void releaseCamera(){
    if (mCamera != null){
        mCamera.release();        // release the camera for other applications
        mCamera = null;
    }
}
</code></pre>

<p>}
```</p>

<h2>5)Saving Media Files</h2>

<p>用户创建的图片或者视频均需要保存到设备的external storage目录下(SD Card)。可以有多种可能的位置用来保存文件，但是作为一个开发人员，只有下面两种标准的路径进行保存。</p>

<ul>
<li><a href="http://developer.android.com/reference/android/os/Environment.html#getExternalStoragePublicDirectory(java.lang.String">Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES)</a>) - 这个方法会返回用来保存图片与视频所推荐使用的标准共享目录。这个目录是共享开放的，所以其他程序可以轻易的发现，读取并删除这个目录下的文件。如果你的程序被用户卸载，在这个目录下的文件不会被移除。为了避免干扰到用户已经存在的图片与视频目录，你应该为你的程序创建一个子目录。如下面的代码所示。这个方法从Android 2.2 (API Level 8)开始就可以使用。</li>
<li><a href="http://developer.android.com/reference/android/content/Context.html#getExternalFilesDir(java.lang.String">Context.getExternalFilesDir(Environment.DIRECTORY_PICTURES)</a>) - 这个方法会返回一个和你的程序相关联的，用来保存图片与视频的，标准目录。如果你的程序被卸载，在这个目录下的文件也会被一起移除。这个目录并不能阻止其他程序的读写。</li>
</ul>


<p>```java
public static final int MEDIA_TYPE_IMAGE = 1;
public static final int MEDIA_TYPE_VIDEO = 2;</p>

<p>/<em>* Create a file Uri for saving an image or video </em>/
private static Uri getOutputMediaFileUri(int type){</p>

<pre><code>  return Uri.fromFile(getOutputMediaFile(type));
</code></pre>

<p>}</p>

<p>/<em>* Create a File for saving an image or video </em>/
private static File getOutputMediaFile(int type){</p>

<pre><code>// To be safe, you should check that the SDCard is mounted
// using Environment.getExternalStorageState() before doing this.

File mediaStorageDir = new File(Environment.getExternalStoragePublicDirectory(
          Environment.DIRECTORY_PICTURES), "MyCameraApp");
// This location works best if you want the created images to be shared
// between applications and persist after your app has been uninstalled.

// Create the storage directory if it does not exist
if (! mediaStorageDir.exists()){
    if (! mediaStorageDir.mkdirs()){
        Log.d("MyCameraApp", "failed to create directory");
        return null;
    }
}

// Create a media file name
String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
File mediaFile;
if (type == MEDIA_TYPE_IMAGE){
    mediaFile = new File(mediaStorageDir.getPath() + File.separator +
    "IMG_"+ timeStamp + ".jpg");
} else if(type == MEDIA_TYPE_VIDEO) {
    mediaFile = new File(mediaStorageDir.getPath() + File.separator +
    "VID_"+ timeStamp + ".mp4");
} else {
    return null;
}
return mediaFile;
</code></pre>

<p>}
```</p>

<h2>6)Camera Features</h2>

<p>Android提供了控制相机特性的方法，例如图片格式化，闪光灯模式，设置聚焦等等。这一段落列出了通常的相机功能并简短的介绍如何使用这些功能。大多数相机特性可以通过<strong>Camera.Parameters</strong>对象来获取并进行相关的设置。然而，有几个重要的功能不仅仅是通过<strong>Camera.Parameters</strong>能够实现的。请看下面的内容介绍：</p>

<ul>
<li>Metering and focus areas：测光并进行聚焦</li>
<li>Face detection：人脸检测</li>
<li>Time lapse video：延时视频</li>
</ul>


<p>关于上面3个常用的功能会在下面进行更加详细的介绍，除此之外的其他相机功能，请参考下面这张表：</p>

<p><img src="/images/articles/camera_features_table.png" title="Camera Common Features" alt="camera_features_table.png" /></p>

<p><strong>Note:</strong> 因为软硬件的差异性，那些功能并不一定都是支持的。对于检查功能是否可用，请参考下面的Checking feature availability.</p>

<h3>6.1)Checking feature availability</h3>

<p>相机的有些功能在所有手机上并不一定是都支持的。在开发相机应用时就需要提前考虑应该适配到哪个Level。然后开发的时候需要动态的去根据功能是否支持来做不同的处理。</p>

<p>你可以通过获取到相机参数的对象来做检测。下面的例子演示了如何检查autofocus功能是否可用：
```java
// get Camera parameters
Camera.Parameters params = mCamera.getParameters();</p>

<p>List<String> focusModes = params.getSupportedFocusModes();
if (focusModes.contains(Camera.Parameters.FOCUS_MODE_AUTO)) {
  // Autofocus mode is supported
}
```</p>

<p>对于大多数的相机特性，都可以使用类型上面的代码来处理。Camera.Parameters对象提供了一系列的类似<code>getSupported...()</code>, <code>is...Supported()</code> 与 <code>getMax...()</code> 方法来判断某个功能是否可用的。</p>

<p>如果你的程序确定需要相机的某个特性，你可以在mainfest文件中就进声明。例如你声明了flash与auto-focus的功能，那么Google Play会阻止那些不支持这些功能的设备安装这个应用。关于相机功能的声明列表，请参考<a href="http://developer.android.com/guide/topics/manifest/uses-feature-element.html#hw-features">Features Reference.</a></p>

<h3>6.2)Using camera features</h3>

<p>前面已经提到过，通过Camera.Parameters对象来操控相机。如下所示：
<code>java
// get Camera parameters
Camera.Parameters params = mCamera.getParameters();
// set the focus mode
params.setFocusMode(Camera.Parameters.FOCUS_MODE_AUTO);
// set Camera parameters
mCamera.setParameters(params);
</code>
上面这种方法对大多数相机功能都是可用的，在你获取到相机的实例之后，大多数参数都是在任意时间均可以修改的。参数修改的效果在相机预览的界面是可以立即看到效果的。在软件层面，实际上可能是需要花几帧的时间来产生效果的，因为需要发送指令给相机硬件产生效果。</p>

<p><strong>Important:</strong> 部分功能是不能修改的。特别是，修改相机预览的角度与大小，是需要先停止预览的。从Android Android 4.0 (API Level 14)开始，预览角度可以不用重启预览就可以进行修改。</p>

<p>下面快速的介绍前面提到的3个功能：</p>

<h4>6.2.1）Metering and focus areas</h4>

<p>在某些拍照场景下，自动聚焦与测光并不能拍出我们想要的效果。从Android 4.0 (API Level 14)开始，支持指定特定的区域用来focus与metering。下面的代码演示了如何指定特定的区域用来focus与metering。</p>

<p>```java
// Create an instance of Camera
mCamera = getCameraInstance();</p>

<p>// set Camera parameters
Camera.Parameters params = mCamera.getParameters();</p>

<p>if (params.getMaxNumMeteringAreas() > 0){ // check that metering areas are supported</p>

<pre><code>List&lt;Camera.Area&gt; meteringAreas = new ArrayList&lt;Camera.Area&gt;();

Rect areaRect1 = new Rect(-100, -100, 100, 100);    // specify an area in center of image
meteringAreas.add(new Camera.Area(areaRect1, 600)); // set weight to 60%
Rect areaRect2 = new Rect(800, -1000, 1000, -800);  // specify an area in upper right of image
meteringAreas.add(new Camera.Area(areaRect2, 400)); // set weight to 40%
params.setMeteringAreas(meteringAreas);
</code></pre>

<p>}</p>

<p>mCamera.setParameters(params);
```
<a href="http://developer.android.com/reference/android/hardware/Camera.Area.html">Camera.Area</a>对象包含了2个参数: 一个Rect对象用来指定区域，另外一个是权重用来告诉相机这部分区域的重要性。</p>

<p>Rect的值是基于2000*2000的坐标体系。(-1000, -1000)表示的左上角，(1000, 1000)表示的是右下角。如下图所示：</p>

<p><img src="/images/articles/camera-area-coordinates.png" title="Figure 1. The red lines illustrate the coordinate system for specifying a Camera.Area within a camera preview. The blue box shows the location and shape of an camera area with the Rect values 333,333,667,667." alt="camera-area-coordinates.png" /></p>

<p>这个坐标系统是于相机的可见预览区域相吻合的，不会因为预览效果的放大缩小二改变。同样的，通过Camera.setDisplayOrientation()旋转预览并不会导致坐标系统的变化。</p>

<h4>6.2.2)Face detection</h4>

<p>对于包含人像的图片，头像是最重要的区域。在拍照的时候，这个区域应该用来作为focus与while balance操作的重要参数。从Android 4.0 (API Level 14)开始，系统能够提供API来动态检测人脸并且可以使用人脸识别技术来计算拍照图片的设置参数。</p>

<p><strong>Note:</strong> 当人脸检测功能开启的时候，<code>setWhiteBalance(String)</code>, <code>setFocusAreas(List)</code> 与<code>setMeteringAreas(List)</code>并没有效果。</p>

<p>使用人脸检测功能需要下面的几个步骤：</p>

<ul>
<li>检测在设备上是否有人脸检测的功能。</li>
<li>创建一个人脸检测的监听器。</li>
<li>把这个人脸检测器添加到Camera对象中。</li>
<li>在预览开启之后启动人脸检测(每次预览重启也是)。</li>
</ul>


<p>通过<a href="http://developer.android.com/reference/android/hardware/Camera.Parameters.html#getMaxNumDetectedFaces(">getMaxNumDetectedFaces()</a>)方法来获取设备是否支持检测人脸。如下面的<code>startFaceDetection()</code>方法中演示的：</p>

<p>为了把人脸检测到得结果反馈到界面上，还需要实现检测的监听器，如下所示：
```java
class MyFaceDetectionListener implements Camera.FaceDetectionListener {</p>

<pre><code>@Override
public void onFaceDetection(Face[] faces, Camera camera) {
    if (faces.length &gt; 0){
        Log.d("FaceDetection", "face detected: "+ faces.length +
                " Face 1 Location X: " + faces[0].rect.centerX() +
                "Y: " + faces[0].rect.centerY() );
    }
}
</code></pre>

<p>}
```</p>

<p>创建完这个类之后，需要把这个Listener加到Camera的对象中，如下所示：
<code>java
mCamera.setFaceDetectionListener(new MyFaceDetectionListener());
</code></p>

<p>你得程序必须在每次启动或者重启相机预览的时候开始人脸检测。如下所示：
```java
public void startFaceDetection(){</p>

<pre><code>// Try starting Face Detection
Camera.Parameters params = mCamera.getParameters();

// start face detection only *after* preview has started
if (params.getMaxNumDetectedFaces() &gt; 0){
    // camera supports face detection, so can start it:
    mCamera.startFaceDetection();
}
</code></pre>

<p>}
```</p>

<p>如果使用前面4.4)Creating a preview class段落中提到的预览类，你需要在<code>surfaceCreated()</code> 与 <code>surfaceChanged()</code>方法中执行<code>startFaceDetection()</code>方法。如下所示：
```java
public void surfaceCreated(SurfaceHolder holder) {</p>

<pre><code>try {
    mCamera.setPreviewDisplay(holder);
    mCamera.startPreview();

    startFaceDetection(); // start face detection feature

} catch (IOException e) {
    Log.d(TAG, "Error setting camera preview: " + e.getMessage());
}
</code></pre>

<p>}</p>

<p>public void surfaceChanged(SurfaceHolder holder, int format, int w, int h) {</p>

<pre><code>if (mHolder.getSurface() == null){
    // preview surface does not exist
    Log.d(TAG, "mHolder.getSurface() == null");
    return;
}

try {
    mCamera.stopPreview();

} catch (Exception e){
    // ignore: tried to stop a non-existent preview
    Log.d(TAG, "Error stopping camera preview: " + e.getMessage());
}

try {
    mCamera.setPreviewDisplay(mHolder);
    mCamera.startPreview();

    startFaceDetection(); // re-start face detection feature

} catch (Exception e){
    // ignore: tried to stop a non-existent preview
    Log.d(TAG, "Error starting camera preview: " + e.getMessage());
}
</code></pre>

<p>}
```
<strong>Note:</strong> 要在startPreview()方法之后才能开启人脸检测。请不要尝试在onCreate()方法里面启动人脸检测。</p>

<h4>6.2.3)Time lapse video</h4>

<p>Time lapse video使得用户可以通过组合一段时间的图片生成视频片段。这个功能利用了<a href="http://developer.android.com/reference/android/media/MediaRecorder.html">MediaRecorder</a>每隔一段时间来记录一张图片。</p>

<p>为了实现这个功能，你需要像配置一个普通的recorder对象一样。如下面的代码所示：
<code>java
// Step 3: Set a CamcorderProfile (requires API Level 8 or higher)
mMediaRecorder.setProfile(CamcorderProfile.get(CamcorderProfile.QUALITY_TIME_LAPSE_HIGH));
...
// Step 5.5: Set the video capture rate to a low number
mMediaRecorder.setCaptureRate(0.1); // capture a frame every 10 seconds
</code>
上面的设置只是对MediaRecorder进行参数设置的一小部分。一旦配置结束，就可以开启视频录制。关于更多的信息，请参考前面的4.7)Capture Video(还没有开始学习)</p>

<p>===</p>

<p>学习自<a href="http://developer.android.com/guide/topics/media/camera.html">http://developer.android.com/guide/topics/media/camera.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Notes(05) - Tasks and Back Stack]]></title>
    <link href="http://hukai.me/blog/android-notes-task-and-back-stack/"/>
    <updated>2013-04-20T20:42:00+08:00</updated>
    <id>http://hukai.me/blog/android-notes-task-and-back-stack</id>
    <content type="html"><![CDATA[<ul>
<li>所有的activities都归属于一个task。</li>
<li>一个task包含了一些activities，这些activities以用户与他们的交互前后为顺序存放在task中。</li>
<li>Tasks可以把activies放置在background并且保存每一个activites的状态，以便于用户可以切换到其他task而不至于丢失之前的活动状态。</li>
</ul>


<h1>要点概述</h1>

<p>一个程序通常包含了多个actvities。每一个activity都应该围绕用户需要执行的一个特定功能而进行设计，并且可以启动其他的activites。例如:一个邮件程序应该拥有一个显示新邮件的列表。当用户选择其中一封邮件，一个新的activity将打开用来显示邮件内容。</p>

<!-- more -->


<p>一个activity甚至可以启动设备上其他程序的activites。例如：如果你的程序想要发送邮件，你可以定义一个intent来表达你的请求。其他可以接收这个请求的程序则会对这个请求作出响应。当使用其他程序的组件把邮件发送出去之后，你自己的activity将会resume，这样另外一个程序的发邮件组件看起来像是你的程序中的一部分。尽管真正发邮件的activites也许是来自其他不同的程序，Android会通过保存那些activites到同一个task中的方式让用户感觉到无缝的体验。</p>

<p>一个task是用户执行一个确定的动作所会用到的activites的集合。那些activities被安置到一个stack中 (也就是"back stack"), 他们以每个activity被打开的顺序方式存放在stack中。</p>

<p>设备Home界面是大多数tasks的起始点。当用户点击程序在launcher或者Home上的启动图标时，这个程序的task则变成了foreground的。如果程序之前不存在task(程序最近并没有被使用过), 那么一个新的task将被创建并且程序的"main" activity将被打开并作为stack的root activity。</p>

<p>当目前的activity启动另外一个activity时，新的activity被压入栈中作为栈顶并且获取到了focus。前面的那个activity则以stopped的状态继续保留在stack中。当一个activity stops时，系统会保留它的UI状态。当用户点击back按钮时，当前的activity从栈顶退出并被destroyed，之前的activity则resume(之前保存的UI状态得到恢复). 在栈中的Activities的是不会被重新排序的，仅仅是做入栈与出栈的动作。当被启动时入栈，用户点击后退时出栈。下图演示了上面提到的情况：</p>

<p><img src="/images/articles/diagram_backstack.png" title="Figure 1. A representation of how each new activity in a task adds an item to the back stack. When the user presses the Back button, the current activity is destroyed and the previous activity resumes." alt="diagram_backstack.png" /></p>

<p>如果用户持续点击back按钮，那么在栈中的每一个activity都会做退栈并显示之前activity的动作, 直到用户退回到Home界面(或者是用户开始task的地方).当所有的activities都从栈中被移除之后，这个task也就消失了。</p>

<p>一个task是一个紧密结合的单元，当用户开始一个新的task或者通过点击Home按钮回到Home桌面时，之前的task会整体移动到background。当在background时，在task中的所有的activity都是stopped状态的。但是这个task的回退栈仍然保留了与系统交互的特质，仅仅是失去了focus而已。如下图所示：</p>

<p><img src="/images/articles/diagram_multitasking.png" title="Figure 2. Two tasks: Task B receives user interaction in the foreground, while Task A is in the background, waiting to be resumed." alt="diagram_multitasking.png" /></p>

<p>一个task可以返回到"foreground"，这样用户可以从他们离开的地方重新开始操作。例如，当前task(Task A)的栈中有三个activities. 用户点击Home按钮，然后从桌面启动一个新的程序. 当Home界面出现时，Task A变成了background的. 当新的程序启动，系统为它启动一个新的task，里面包含了它自己的activites. 在用户与那个程序交互完之后，重新退回桌面并选择之前启动的task A. 这个时候，Task A重新回到foreground, 在stack中的那三个activities被重新选中，栈顶的那个activity被resume. 此时，用户仍然可以选择通过切回Home，再次启动task B.( 或者通过长按Home按钮触发最近使用的task界面进行选择). 这便是Android中的多任务的一个例子.</p>

<p><strong>Note:</strong> 众多tasks都可以一并在后台被Hold住。然而，如果用户同时执行了多个后台任务，系统便会为了恢复内存而开始销毁后台activities. 这会导致activity状态丢失. 关于着部分内容，请看下面的Activity state部分.</p>

<p>因为在back stack中的activities是不会被重新调整顺序的。如果你的程序中的某个特定的activity可以被多个activity所叫起，那么将会为那个特定activity创建一个新的实例并压入栈中(而不是把那个activity之前的实例移动到栈顶). 如下图所示:你程序中的一个activity可以被多次实例化(即使是在不同的task中)。如果用户通过点击Back按钮回退，每一个实例都将以他们被打开的顺序依次被重新呈现。然而，如果你不想一个activity被重复实例化，你可以修改这种行为。关于如何修改这种行为，将在下面的Managing Tasks中讲到.</p>

<p><img src="/images/articles/diagram_multiple_instances.png" title="Figure 3. A single activity is instantiated multiple times." alt="diagram_multiple_instances.png" /></p>

<p><strong>总结一下系统默认的activities与tasks的行为:</strong></p>

<ul>
<li>当Activity A启动Activity B时, Activity A会是stopped, 但是系统会保存它的状态(例如scroll的位置与填表格的文字). 如果用户在activity B时点击Back按钮，那么activity A会恢复它之前保存的状态信息.</li>
<li>当用户通过点击Home按钮离开一个task时，当前的activity会是stopped并且它的task会退到background. 系统保留task中的每一个activity. 如果用户之后通过点击启动图标来重新叫起它,task会成为foreground的并且栈顶的activity会得到恢复.</li>
<li>如果用户点击Back按钮, 当前activity会从栈中退出并被destroyed. 在栈中的前一个activity得到resumed. 当一个activity被destroyed, 系统不会再保留activity的状态信息.</li>
<li>Activities可以被多次实例化，即使是请求来自其他tasks.</li>
</ul>


<h1>Saving Activity State(保存Activity状态)</h1>

<p>正如上面提到的，当activity stopped时，系统默认会保存它的状态. 这样的话, 当用户回退到之前的activity, 它的UI将和离开时一致. 然而, 如果activity被destoryed并且需要recreated时，你可以并且应该主动使用activity的callback方法来保存它的状态信息.</p>

<p>当系统stop你的某个activity时, 系统可能会在需要恢复内存时destory那个stop状态的activity. 当发生这件事时，关于activity的状态信息则会丢失. 即使真的发生那样的情况, 系统仍然为那个activity在back stack中保留了位置, 但是当这个activity成为栈顶activity时, 系统必须recreate它(而不是resume它). 为了避免丢失用户的工作内容, 你应该主动通过实现<a href="http://developer.android.com/reference/android/app/Activity.html#onSaveInstanceState(android.os.Bundle">onSaveInstanceState()</a>)回调方法来保存那些信息.</p>

<p>想了解更多关于如何保存activity的状态，请参考<a href="http://developer.android.com/guide/components/activities.html#SavingActivityState">Activities</a>.</p>

<h1>Managing Tasks(管理Tasks)</h1>

<p>Android系统默认的管理tasks与back stack的方法使用于大部分情况, 对于大多数程序来说, 你不需要担心你的activites是如何与task进行联系的，它们又是如何存放在back stack中的. 但是你可能想要打断通常的行为, 可能你想要在你的程序中的某个activity被启动时会创建一个新的task而不是放置到旧的task中; 或者, 当你启动一个activity，你想要把已经存在的某个实例放置到栈顶(而不是在栈顶创建一个新的实例); 又或者说, 你想要在用户退出task时除了根activity之外清除栈中其它的activities.</p>

<p>你可以通过在manifest的<activity>标签下设置属性，并且在把intent传递给startActivity()方法之前为intent设置flag.</p>

<p>关于此事, 在<activity>标签下可以设置的主要属性为:<br/>
* taskAffinity
* launchMode
* allowTaskReparenting
* clearTaskOnLaunch
* alwaysRetainTaskState
* finishOnTaskLaunch</p>

<p>你可以为intent设置flag的主要值有:<br/>
* FLAG_ACTIVITY_NEW_TASK
* FLAG_ACTIVITY_CLEAR_TOP
* FLAG_ACTIVITY_SINGLE_TOP</p>

<p>下面将会讲解如何使用上面定义的方法<br/>
<strong>Caution:</strong> 大多数程序不应该打断系统默认的activities与tasks之间的行为. 如果你确定有必要修改默认的行为, 请谨慎使用并确保用户切换与回退的行为是可用正常的. 请确保你的设计行为不会对用户期待的体验有冲突.</p>

<h2>(0)Defining launch modes(定义启动模式)</h2>

<p>启动模式允许你定义一个activity的实例与当前task是如何结合的. 你可以用下面两种方式来定义不同的启动模式:</p>

<ul>
<li><p><strong>Using the manifest file</strong><br/>
当你在manifest文件中定义一个activity时，你可以指定当它启动时与task的结合方式.</p></li>
<li><p><strong>Using Intent flags</strong><br/>
当你调用startActivity(), 你可以对intent进行设置flag来表示这个activity将与task如何进行结合.</p></li>
</ul>


<p>像这样, 如果Activity A 启动 Activity B, 那么Activity B 可以在它的manifest中定义它应该如何与当前的task进行联合，同样Activity A 也可以请求Activity B 应该如何与当前task进行结合. <strong>如果两个都有定义，那么A的请求(定义在Intent中的)的优先级比B的请求(定义在manifest中)要更高</strong>.</p>

<p><strong>Note:</strong>某些可以定义在manifest中的启动模式并不一定在intent flag中可以找到对应的方式. 同样,某些在intent flag中可以找到的并不一定可以在manifest中进行设置.</p>

<h3>Using the manifest file</h3>

<p>在manifest的<activity>标签下设置<strong>launchMode</strong>属性，一共可以设置下面4种类型的启动模式:</p>

<hr />

<ul>
<li><strong>"standard"</strong> (the default mode)</li>
</ul>


<p>系统默认的启动模式. 系统在task中创建一个新的实例，activity可以被多次实例化. 每一个实例可以属于不同的task, 同样一个task可以有多个实例.</p>

<ul>
<li><strong>"singleTop"</strong></li>
</ul>


<p>如果activity的实例已经存在于当前task的栈顶, 系统会通过调用它的onNewIntent()方法把intent导向那个实例, 而不是为那个activity创建新的实例. activity可以被多次实例化，每一个实例可以属于不同的tasks, 同样一个task可以有多个实例 (仅仅当目前栈顶activity不是那个activity时才行，否则栈顶元素就是想要创建的activity的实例的话，则不会重复创建).</p>

<p>例如, 某个栈中的元素由root至top依次为activity A-B-C-D; Acivity D是栈顶. 一个intent来到activity D中. 如果D是默认的"standard"启动模式, 那么stack则会变成A-B-C-D-D. 然而, 如果D的启动模式是"singleTop", 那么D将通过onNewIntent()来接受那个intent, 栈结构仍然是A-B-C-D. 然而, 如果Activity B接受到一个intent, 那么即使现在是single top模式，仍然会创建一个新的B加入到栈中.(A-B-C-D-B)</p>

<p><strong>Note:</strong> 当一个activity的实例被创建时，用户可以点击Back按钮来回退到之前的activity. <strong>但是当已经存在的某个实例需要处理一个新的intent时，用户在这个intent还没有到达onNewIntent()方法之前是没有办法通过点击back按钮来回退的.</strong></p>

<ul>
<li><strong>"singleTask"</strong></li>
</ul>


<p>系统会创建一个新的task并把实例化的activity作为task的root元素(这个task还可以继续添加其他activity的实例). <strong>然而, 如果这个activity的实例已经存在于另外一个task中，系统会通过调用onNewIntent()方法把intent导向已经存在的实例中, 而不是创建一个新的实例. 某一时刻，activity的实例只能存在一个.</strong></p>

<p><strong>Note:</strong>尽管activity是在一个新的task中被启动的, Back按钮仍然是可以回退到上一个activity的.</p>

<ul>
<li><strong>"singleInstance".</strong></li>
</ul>


<p>除了系统不会再对拥有的那个activity的task添加新的其他实例之外，与"singleTask"是类似的. activity的实例总是唯一的，并且是task中唯一的一个元素. 并且task是新创建的.</p>

<hr />

<p>另外一个例子, Android的Browser程序通过为web browser activity在manifest中指定singleTask模式定义了activity总是在它自己的taks中打开. 这意味着，如果你的程序定义了一个intent来打开Android Browser, 它的activity并不是在你的程序task中被打开的. 要么为browser启动一个新的task，要么把browser正在后台允运行的task带到forgound来处理那个Intent.<br/>
<strong>???</strong>(<em>奇怪，前面不是说intent请求的优先级比manifest中的要高吗？这里怎么会这样？</em>)</p>

<p>不管是启动一个新的task还是在原来的task中，Back按钮都可以回退到前面的activity. 然而，如果你启动的activity的launch mode定义为singleTask, 然后如果那个activity的某个实例已经存在于一个background的task中，那么这个background的task的所有activites会<strong>整个全部</strong>被带到foreground的. 下图Figure 4 演示了这种情况：</p>

<p><img src="/images/articles/diagram_backstack_singletask_multiactivity.png" title="Figure 4. A representation of how an activity with launch mode &quot;singleTask&quot; is added to the back stack. If the activity is already a part of a background task with its own back stack, then the entire back stack also comes forward, on top of the current task." alt="diagram_backstack_singletask_multiactivity.png" /></p>

<p><strong>Note:</strong> 通过manifest中launchMode属性设置的方式定义的启动模式可以被intent中的flag所覆盖，请看下面的解释.</p>

<h3>Using Intent flags</h3>

<ul>
<li><p>FLAG_ACTIVITY_NEW_TASK<br/>
在新的task中启动activity. 如果你要启动的activity已经存在于某个运行的task中, 那么这个task会整个被提升为foregound的，activity会通过onNewIntent()来接收intent.这部分的行为与singleTask启动模式是一致的.</p></li>
<li><p>FLAG_ACTIVITY_SINGLE_TOP<br/>
如果在栈顶的activity接受到这样的intent, 那么已经存在于栈顶的实例会通过onNewIntent()来获取intent, 而不是创建一个新的实例. 这部门的行为与singleTop启动模式是一致的.</p></li>
<li><p>FLAG_ACTIVITY_CLEAR_TOP<br/>
如果被启动的activity已经存在于当前运行的task中, 不是为那个activity启动一个新的实例，而是在这个activity实例之上的activities都被destoryed，intent被通过onNewIntent()传递到这个实例中，并且这个时候，它就成了栈顶元素. 这个行为在launchMode的属性中并没有对应的值.<br/>
FLAG_ACTIVITY_CLEAR_TOP通常与FLAG_ACTIVITY_NEW_TASK同时使用. 当他们结合一起时，那意味着把已经存在的activity放置到另外一个task中并且把它作为栈顶元素开始与用户进行交互.</p></li>
</ul>


<p><strong>Note:</strong>如果被启动的activity的launch mode是"standard", 那么这个activity同样会被先清除掉，然后创建一个新的实例来接受intent. 那是因为当launch mode是standard时，新的实例总是为了新的intent而被创建.</p>

<h2>(1)Handling affinities(处理联姻关系)</h2>

<p>Affinity(联姻)意味着activity更倾向归属于哪一个task. 默认的，来自同一程序的所有的activities会拥有同样的联姻关系. 因此，他们更倾向于处于同一个task中. 然而, 你可以修改这种默认的行为. 在不同程序中的activites可以有同样的联姻关系，或者同一程序中的不同activites可以分配到不同的task联姻关系中</p>

<p>可以在manifest的activity中设置taskAffinity属性，一共有下面两种情况：</p>

<ul>
<li>When the intent that launches an activity contains the FLAG_ACTIVITY_NEW_TASK flag.</li>
</ul>


<p>A new activity is, by default, launched into the task of the activity that called startActivity(). It's pushed onto the same back stack as the caller. However, if the intent passed to startActivity() contains the FLAG_ACTIVITY_NEW_TASK flag, the system looks for a different task to house the new activity. Often, it's a new task. However, it doesn't have to be. If there's already an existing task with the same affinity as the new activity, the activity is launched into that task. If not, it begins a new task.<br/>
If this flag causes an activity to begin a new task and the user presses the Home button to leave it, there must be some way for the user to navigate back to the task. Some entities (such as the notification manager) always start activities in an external task, never as part of their own, so they always put FLAG_ACTIVITY_NEW_TASK in the intents they pass to startActivity(). If you have an activity that can be invoked by an external entity that might use this flag, take care that the user has a independent way to get back to the task that's started, such as with a launcher icon (the root activity of the task has a CATEGORY_LAUNCHER intent filter; see the Starting a task section below).</p>

<ul>
<li>When an activity has its allowTaskReparenting attribute set to "true".</li>
</ul>


<p>In this case, the activity can move from the task it starts to the task it has an affinity for, when that task comes to the foreground.<br/>
For example, suppose that an activity that reports weather conditions in selected cities is defined as part of a travel application. It has the same affinity as other activities in the same application (the default application affinity) and it allows re-parenting with this attribute. When one of your activities starts the weather reporter activity, it initially belongs to the same task as your activity. However, when the travel application's task comes to the foreground, the weather reporter activity is reassigned to that task and displayed within it.</p>

<p><strong>Tip:</strong> 如果一个.apk文件从用户的角度看包含了不止一个"application"的话，你可能会想要使用taskAffinity属性来为那些activites设置不同的联姻关系.</p>

<h2>(2)Clearing the back stack(清除回退栈)</h2>

<p>如果用户长时间离开一个task, 系统会清除task中root activity之外的所有的activites. 当用户回退到task时，仅仅只有root activity会被恢复.</p>

<p>有下面一些值可以用来设置，如果你想修改系统默认的行为的话:</p>

<ul>
<li><p><strong>alwaysRetainTaskState</strong><br/>
设置了这个属性为true之后，即使很长时间，也不会被destory的</p></li>
<li><p><strong>clearTaskOnLaunch</strong><br/>
如果这个属性设置为true，那么就是与alwaysRetainTaskState相反的. 每次启动都会清除root以上的activities.</p></li>
<li><p><strong>finishOnTaskLaunch</strong><br/>
这个属性与clearTaskOnLaunch类似, 但是它仅仅是对单个activity进行操作，而不是整个task. It can also cause any activity to go away, including the root activity. When it's set to "true", the activity remains part of the task only for the current session. If the user leaves and then returns to the task, it is no longer present.</p></li>
</ul>


<h2>(3)Starting a task(启动一个任务)</h2>

<p>你可以启动一个activity作为一个task的起点，通过为它的intent filter设置"android.intent.action.MAIN"作为特定的action，设置"android.intent.category.LAUNCHER"作为特定的category. 例如：
```xml
<activity ... ></p>

<pre><code>&lt;intent-filter ... &gt;
    &lt;action android:name="android.intent.action.MAIN" /&gt;
    &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
&lt;/intent-filter&gt;
...
</code></pre>

<p></activity>
```
上面的设置方式不仅仅是使得这个activity作为launcher的图标，允许用户通过点击它启动activity并且随时通过点击它来触发恢复之前的task.</p>

<p>第二点非常重要: 用户必须能够在离开task之后通过activity的launcher来回到task. 因为这点, "singleTask" 与 ""singleInstance" 这两种启动模式总是会初始化一个task, 需要有ACTION_MAIN 与 CATEGORY_LAUNCHER 配合. 例如，用户启动了一个task做了一些动作，然后点击Home回到桌面，这个时候想要回到刚才的task，需要有launcher作为入口.</p>

<p>对于那些你不想用户可以回退的情况，请设置<activity>标签下的finishOnTaskLaunch属性为"true" (参考上面的章节).</p>

<hr />

<p><strong>文章学习自<a href="http://developer.android.com/guide/components/tasks-and-back-stack.html">http://developer.android.com/guide/components/tasks-and-back-stack.html</a></strong><br/>
<strong>转载请注明出自<a href="http:://kesenhoo.github.com">http://kesenhoo.github.com</a>，谢谢</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Notes(04) - Intents and Intent Filters]]></title>
    <link href="http://hukai.me/blog/android-notes-intent-and-intentFilter/"/>
    <updated>2013-04-12T18:27:00+08:00</updated>
    <id>http://hukai.me/blog/android-notes-intent-and-intentFilter</id>
    <content type="html"><![CDATA[<h2>Intent与Intent Filter</h2>

<p>Android其中的三大组件，Activity,Service与broadcast receivers是通过Intent来触发彼此的。Intent本身会携带一些信息，它是一种组件内部或者组件间进行交互的中介。<br/>
对于不同的组件之间有着不同的机制：</p>

<ul>
<li>一个Intent对象通过Context.startActivity()或者Activity.startActivityForResult()来启动一个activity或者让已经存在的activity做一些更新的操作。</li>
<li>一个Intent对象通过Context.startService()来初始化一个Service或者给已经在运行的Service传递新的指令。同样的，对于Context.bindService()是一样的道理。</li>
<li>Intent对象通过broadcast的方法（例如Context.sendBroadcast(), Context.sendOrderedBroadcast()或者Context.sendStickyBroadcast())传递给那些感兴趣的broadcast receivers.</li>
</ul>


<!-- more -->


<p>每一种不同类型的intent都会由系统传递到对应的组件上，下面会介绍Android系统是如何根据Intent里面的参数进行分类处理并传递到符合要求的组件上的。</p>

<h3>Intent对象</h3>

<p>一个Intent对象是许多信息的一个bundle.通常来说，它可以包含下面的内容：</p>

<ul>
<li><p>Component name组件名</p>

<ul>
<li>指定处理这个intent的组件。包名与包中的组件名。组件名是可选的。如果设置了组件名，这个intent就会传递给对应的类。如果没有设置组件名，Android会利用Intent对象中的其他信息来判断传递的对象。</li>
<li>可以通过setComponent(), setClass()或者setClassName()来设置组件名，并通过getComponent()来读取组件名.</li>
</ul>
</li>
<li><p>Action动作意图<br/>
一个String名称来表示执行Intent的意图是什么，Intent类定义了一些action常量，如下：</p></li>
</ul>


<hr />

<table>
   <tr>
      <td>Constant</td>
      <td>Target component</td>
      <td>Action</td>
   </tr>
   <tr>
      <td>ACTION_CALL</td>
      <td>activity</td>
      <td>Initiate a phone call.</td>
   </tr>
   <tr>
      <td>ACTION_EDIT</td>
      <td>activity</td>
      <td>Display data for the user to edit.</td>
   </tr>
   <tr>
      <td>ACTION_MAIN</td>
      <td>activity</td>
      <td>Start up as the initial activity of a task, with no data input and no returned output.</td>
   </tr>
   <tr>
      <td>ACTION_SYNC</td>
      <td>activity</td>
      <td>Synchronize data on a server with data on the mobile device.</td>
   </tr>
   <tr>
      <td>ACTION_BATTERY_LOW</td>
      <td>broadcast receiver</td>
      <td>A warning that the battery is low.</td>
   </tr>
   <tr>
      <td>ACTION_HEADSET_PLUG</td>
      <td>broadcast receiver</td>
      <td>A headset has been plugged into the device, or unplugged from it.</td>
   </tr>
   <tr>
      <td>ACTION_SCREEN_ON</td>
      <td>broadcast receiver</td>
      <td>The screen has been turned on.</td>
   </tr>
   <tr>
      <td>ACTION_TIMEZONE_CHANGED</td>
      <td>broadcast receiver</td>
      <td>The setting for the time zone has changed.</td>
   </tr>
</table>


<hr />

<p>更多通用的常量定义，请查看<a href="http://developer.android.com/reference/android/content/Intent.html">Intent</a>类的描述。<br/>
你可以定义自己的action string来激活你程序中的其他组件。那些action请遵循把包名作为前缀的规则：例如"com.example.project.SHOW_COLOR".</p>

<ul>
<li><p>Data数据
不同的action会有不同类型的数据。例如，如果你的action是ACTION_EDIT,那么数据应该包含想要编辑的文件URI。如果action是ACTION_CALL,数据应该是tel: URI的格式。同样的，如果action是ACTION_VIEW，那么数据应该是http: URI。接受的action的activity会负责去处理那些指定的数据。<br/>
数据的MIME类型也是非常重要的，例如，一个可以显示图片数据的组件不应该被叫起来做播放音频的动作。<br/>
在许多情况下，数据类型可以从URI中读取到。但是数据类型同样可以显示的定义在Intent对象中。setData()方法指定了数据的URL，setType()方法指定了MIME类型, 同时setDataAndType()方法则可以同时指定URI与MIME。URI可以通过getData()来读取，数据类型则可以通过getType()来读取.</p></li>
<li><p>Category分类
指定哪一类的组件应该处理这个intent。Intent有定义一些分类，如下:</p></li>
</ul>


<hr />

<table>
   <tr>
      <td>Constant</td>
      <td>Meaning</td>
   </tr>
   <tr>
      <td>CATEGORY_BROWSABLE</td>
      <td>The target activity can be safely invoked by the browser to display data referenced by a link — for example, an image or an e-mail message.</td>
   </tr>
   <tr>
      <td>CATEGORY_GADGET</td>
      <td>The activity can be embedded inside of another activity that hosts gadgets.</td>
   </tr>
   <tr>
      <td>CATEGORY_HOME</td>
      <td>The activity displays the home screen, the first screen the user sees when the device is turned on or when the Home button is pressed.</td>
   </tr>
   <tr>
      <td>CATEGORY_LAUNCHER</td>
      <td>The activity can be the initial activity of a task and is listed in the top-level application launcher.</td>
   </tr>
   <tr>
      <td>CATEGORY_PREFERENCE</td>
      <td>The target activity is a preference panel.</td>
   </tr>
</table>


<hr />

<p>请查看<a href="http://developer.android.com/reference/android/content/Intent.html">Intent</a>获取完整的分类列表.<br/>
addCategory()方法可以把某个intent对象加入到指定的分类中，也可以通过removeCategory()来移除，使用getCategories()来获取当前对象中的所有分类。</p>

<ul>
<li><p>Extras额外的值
Intent对象有一系列put...() 方法来插入不同类型的数据，get...() 方法来读取数据. 那些方法可以对数据进行序列化处理成一个bundle对象。实际上，我们也可以new一个bundle对象，通过putExtras() 与 getExtras() 方法来进行处理.</p></li>
<li><p>Flags标志
Flags用来表示，如何启动一个activity(例如，指定activity应该属于哪一个task) 并且在activity被启动后，这个activity在系统中的状态是怎么样的 (例如，是否应该属于最近使用的activity列表中). 所有的flag都在Intent类中有定义。</p></li>
</ul>


<p>想了解如何启动Android系统内的组件，请查看<a href="http://developer.android.com/guide/appendix/g-app-intents.html">list of intents</a>.</p>

<h2>Intent Resolution[Intent详解]</h2>

<p>Intents应该可以分成两类:<br/>
* <strong>Explicit</strong>显式intents通过组件名来指定目标组件。因为组件名不一定可以被其他应用程序的开发者所了解，显式intent通常用来程序内部传递消息：例如activity启动一个下属级别的service或者是启动一个同级的activity。Android系统会根据组件名来把intent送到指定的组件上。<br/>
* <strong>Implicit</strong>隐式intents并不指定特定的组件名。Implicit intents通常用来触发其他应用程序里面的组件。Android系统通过intentFilter来筛选出合适的组件来接收这个intent。没有定义IntentFilter的组件只能接受显式的intent，而定义了intentFilter的组件则可以接受显式与隐式两种类型的intent。</p>

<h3>Intent filters[Intent过滤器]</h3>

<ul>
<li>Activities, services 与 broadcast receivers可以有一个或者多个intent filter.每一个filter都描述了一种可以通过筛选的intent。一个intent要像被这个组件所接收到，必须满足这个组件的所有filter中的一个。</li>
<li>接收intent的组件会根据接收到的数据来决定做不同的动作。<br/>
<strong>注意</strong>:intent filter并不能用来做安全性的检查。因为如果某个显式的intent通过组合多个action与data,指定发送到组件，这样就没有办法起到filter的作用了。</li>
<li>intent filter是<a href="http://developer.android.com/reference/android/content/IntentFilter.html">IntentFilter</a>的实例。因为Android系统需要在组件被启动之前知道它的过滤值，所以一般都是直接写在AndroidManifest.xml里面。其中一个例外是broadcast receiver可以通过Context.registerReceiver()来动态进行注册。</li>
<li><p>一个filter会对action,data与category进行序列化处理。一个隐式的intent均需要通过前面三方面的过滤。如果其中某一项不符合，Android系统將过滤掉这个事件。另外，如果组件有定义多个filter，那么只要满足其中一个filter就可以让其通过。</p></li>
<li><p>Action test
<code>xml
&lt;intent-filter . . . &gt;
  &lt;action android:name="com.example.project.SHOW_CURRENT" /&gt;
  &lt;action android:name="com.example.project.SHOW_RECENT" /&gt;
  &lt;action android:name="com.example.project.SHOW_PENDING" /&gt;
  . . .
&lt;/intent-filter&gt;
</code>
如果某个intent有定义action，那么想要通过上面的测试，必须满足其中一条action.同时，如果intent没有定义任何action，则默认是可以通过的。</p></li>
<li><p>Category test
<code>xml
&lt;intent-filter . . . &gt;
  &lt;category android:name="android.intent.category.DEFAULT" /&gt;
  &lt;category android:name="android.intent.category.BROWSABLE" /&gt;
  . . .
&lt;/intent-filter&gt;
</code>
与action类似，如果有定义category，想要通过，则必须满足filter中的任意一条，否则，如果没有定义category，则默认可以通过。<br/>
然而，activity如果想要接收隐式的intent，那么在activity的filter里面必须包含"android.intent.category.DEFAULT"。</p></li>
<li><p>Data test
<code>xml
&lt;intent-filter . . . &gt;
  &lt;data android:mimeType="video/mpeg" android:scheme="http" . . . /&gt;
  &lt;data android:mimeType="audio/mpeg" android:scheme="http" . . . /&gt;
  . . .
&lt;/intent-filter&gt;
</code>
每一个<data>标签都可以指定一个URI与一个数据类型(MIME media type). 格式像下面定义的那样：
<code>xml
scheme://host:port/path
</code>
例如：content://com.example.project:200/folder/subfolder/etc<br/>
那些属性是可选的，但是他们并不是相互独立的。例如，一个路径想要有意义，必须指定scheme与authority.<br/>
他们有着下面一些规则需要遵守：</p></li>
<li><p>一个既没有URI也没有数据类型的Intent对象，只有在filter没有指定任何URI或者数据类型的情况下才能通过。</p></li>
<li>一个包含URI但是没有数据类型的Intent对象，符合filter定义的URI,同时filter并没有定义数据类型，这样这个对象能够通过。这种情况仅仅发生在类似<strong>mailto:</strong>与<strong>tel:</strong>，他们并没有指定任何实际的数据。</li>
<li>一个包含数据类型但是没有定义URI的Intent对象，仅仅在fliter拥有同样的数据类型而且也没有定义URI的情况下，才能通过。</li>
<li>一个即包含URI又包含数据类型的(或者数据类型可以从URI中获取到)Intent对象。如果与filter中的URI相匹配，这URI部分可以通过。如果数据类型也匹配，则数据部分也可以通过。有个例外，<strong>如果intent的URI是content: 或者 file: ，然而filter却没有定义任何URI(只定义了数据类型)，这样的话，同样能够通过。也就是说content:与file:是特例。</strong></li>
</ul>


<hr />

<p>如果一个intent可以通过多个组件的filter，那么系统会提示用户选择启动哪一个组件。如果没有一个组件满足，则会发生异常。</p>

<h3>Common cases[常见情况]</h3>

<p>上面最后一条规则说明组件可以从文件或者content provider中获取本地的数据。因此，他们的filter可以仅仅需要指定数据类型，而不用显式指定content: 与 file: 的URI. 这是一个很常见的Case.</p>

<ul>
<li>下面的filter将使得符合条件的组件从content provider获取图片数据并进行显示
<code>xml
&lt;data android:mimeType="image/*" /&gt;
</code></li>
<li>从网络获取video数据并进行显示
<code>xml
&lt;data android:scheme="http" android:type="video/*" /&gt;
</code></li>
</ul>


<h3>Using intent matching[intent匹配模式]</h3>

<ul>
<li><p>Intents与intent filters进行匹配，不仅仅是为了寻找待激活的某个组件，而且是为了寻找符合条件的所有的组件。例如，Android系统会把那些intent filter中包含android.intent.action.MAIN" action与"android.intent.category.LAUNCHER" category的组件作为程序的入口(icon launcher).同样的，它通过"android.intent.category.HOME"来寻找桌面组件。</p></li>
<li><p><a href="http://developer.android.com/reference/android/content/pm/PackageManager.html">PackageManager</a>有一组query...()方法来查询那些符合intent条件的组件，还提供了一组resolve...() 方法来决定最佳的组件对intent进行响应。例如，<a href="http://developer.android.com/reference/android/content/pm/PackageManager.html#queryIntentActivities(android.content.Intent,%20int">queryIntentActivities()</a>)返回所有符合参数intent描述的activity。<a href="http://developer.android.com/reference/android/content/pm/PackageManager.html#queryIntentServices(android.content.Intent,%20int">queryIntentServices()</a>)则返回符合条件的sevice。同样的，对<a href="http://developer.android.com/reference/android/content/pm/PackageManager.html#queryBroadcastReceivers(android.content.Intent,%20int">queryBroadcastReceivers()</a>)也是一样.</p></li>
</ul>


<hr />

<p><strong>文章学习自<a href="http://developer.android.com/guide/components/processes-and-threads.html">http://developer.android.com/guide/components/processes-and-threads.html</a></strong><br/>
<strong>转载请注明出自<a href="http:://kesenhoo.github.com">http://kesenhoo.github.com</a>，谢谢</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Notes(03) - Process and Thread]]></title>
    <link href="http://hukai.me/blog/android-notes-process-and-thread/"/>
    <updated>2013-03-31T16:27:00+08:00</updated>
    <id>http://hukai.me/blog/android-notes-process-and-thread</id>
    <content type="html"><![CDATA[<p><img src="/images/articles/process_and_thread.jpg"></p>

<p>当程序的第一个组件开始启动时，Android系统会为这个程序启动一个新的Linux进程。默认的，程序中的后续其他组件都是运行在这个进程的线程中(这个线程被成为"主"线程:main thread)。如果程序的组件在启动时发现已经存在这个程序的进程了(因为其他组件正在运行)， 那么这个组件将启动在该进程中，并使用同一线程。然而，你可以安排程序中的不同组件运行在另外一个进程中，而且你可以为任何进程创建其它的线程。</p>

<h1>Process：进程</h1>

<p>默认的，同一程序的所有组件都是运行在一个Proces里面的，并且大多数程序都不应该去改变这一规则。然而，如果你需要控制某一确定的组件的Proces，你可以在manifest文件中做特殊设置。<em>Music播放器的Playback Service就可以这样做</em></p>

<!-- more -->


<p>manifest中的activity，service，receiver与provider的标签都可以支持<strong>android:process</strong>的属性，它可以为这个组件的运行指定一个特定的进程。这样你可以为某些组件设置运行的进程而其他组件共享一个进程。你还可以通过设置进程属性使得不同程序的运行在同一个进程，共享同一个Linux ID，并且签有同样的签名。</p>

<p>application标签也可以支持设置<strong>android:process</strong>属性，这样会给所有的组件设置一个默认的进程值。</p>

<p>Android会在系统内存紧张时决定关闭某些进程。那么程序中的运行的组件会因此被摧毁掉。当他们需要再次运行时会重新启动一个进程。</p>

<p>当决定杀掉哪一个进程时，Android系统会自动衡量进程的重要性。例如，一个在屏幕上不再可见的进程相对于那些有组件正在被显示的进程更容易被杀掉是显得合理的。那么衡量的权重后面会讲到。</p>

<h1>Process lifecycle：进程生命周期</h1>

<p>Android系统会尝试尽可能的维持程序的存在。但是当需要为新的或者更重要的进程开辟内存空间的时候，最终某些程序是会要被拿掉。为了决定存活当中的程序哪些该拿掉，哪些该留下，系统会根据每一个进程的组件与组件运行状态来生成一个"importance hierarchy"（权重层级）。那些权重低的进程将依次被移除，直到系统恢复了足够的资源。</p>

<p>在权重层级中，一个有5个层次。下面列出了不同类型进程的权重：</p>

<ol>
<li><strong>Foreground process</strong>：<br/>
用户目前正在使用的进程。要成为此类型的进程需要满足下面的任意一点：

<ul>
<li>该进程拥有一个用户正在交互的页面。（onResume方法正在执行）</li>
<li>该进程拥有一个Service，该Service绑定到正在与用户交互的Activity中。</li>
<li>该进程拥有一个in the foreground的Service,通过执行startForeground().</li>
<li>该进程拥有一个Service，正在执行Service的某些callbacks方法(onCreate()， onStart()，或者onDestroy()).</li>
<li>该进程拥有一个BroadcastReceiver，并且在执行它的onReceive()方法。</li>
</ul>
</li>
<li><strong>Visible process</strong>
一个没有任何foreground组件，但是仍然能够影响屏幕呈现内容的进程。需要满足下面条件之一：

<ul>
<li>该进程没有任何foreground的组件，但是仍然对用户可见。例如onPause()被调用的情况，started dialog。</li>
<li>该进程拥有一个一个Service，并且该Service绑定到某个Visible的activity上。</li>
</ul>
</li>
<li><strong>Service process</strong><br/>
一个进程拥有正在运行的Service，该Service是通过startService()的方式被启动的，并且不会进入到前面的两种高权重的层级。尽管Service进程没有与用户看到的部分有直接关系，但是他们通常是在做用户关心在意的工作（例如后台播放音乐，后台下载网络数据），因此系统会保持他们能够运行，除非现有的内存已经不够维持前面2个权重层级的进程使用。</li>
<li><strong>Background process</strong><br/>
进程拥有一个activity，并且这个activity不被用户所见（例如activity的onStop方法被执行）。这些进程对用户体验没有直接的影响，系统可以杀掉这些进程为前面三个层级的进程空出内存。通常来说，系统中存在许多后台进程正在运行，因此他们被保存为一个LRU(least recently used)列表，用来确保最近被使用过的activity会被最后杀死。如果一个activity正确的实现了它的生命周期函数，可以保存它的当前状态。那么杀掉该进程并不会对用户体验有明显的影响。因为当用户重新回到这个Activity时，activity可以所有可见时的状态。</li>
<li><strong>Empty process</strong><br/>
该进程没有拥有任何激活状态的程序组件。保持该进程存在的唯一理由是为了缓存。使用缓存可以提升程序的下次启动时间。系统通常会权衡所有的资源来决定杀掉哪些缓存程序。</li>
</ol>


<p><strong>取最高优先级</strong><br/>
如果一个程序中有好几种优先级的组件，Android系统会把其中最高级别的当作整个程序的权重。例如，如果一个进程拥有一个service与一个visible activity，这个进程会被当作是一个visible进程而不是service进程。</p>

<p><strong>提升优先级</strong><br/>
另外，一个进程的排名会因为其依赖的组件的权重提升而提升。例如，进程A本来是权重为3的，但是它的某个组件与另外一个权重为1的进程B进行绑定后，进程A的权重也会被提升为1。</p>

<p>因为一个执行service的进程的排名比一个后台activity的进程排名要高，所以，如果一个activity启动时要执行一段长时间的操作，应该选择使用Service而不是创建一个worker thread。例如，一个activity做上传图片的操作，应该选择启动一个Service做上传的动作。使用service能确保这个操作会至少有"service process"的优先级。</p>

<h1>Thread</h1>

<p>当一个程序首次启动，系统会为这个程序创建一个<strong>"main thread"</strong>。这个线程非常重要，因为它将肩负起UI的控制调度，还包含绘制图像的事件。同时，它还是与UI相关的组件（来自android.widget与android.view下的组件）进行交互的中介。因此，有些时候main thread 也被成为<strong>"UI thread"</strong>.</p>

<p>系统不会为每一个组件的实例创建单独的线程。所有运行在同一个进程中的组件都会在UI Thread中被实例化。系统调用组件与他们自身的回调函数都是运行在UI Thread的。</p>

<p>例如，当用户点击屏幕上的一个button，程序的UI thread会把这个事件分发至button这个组件上，然后button会执行它的presss state并post an invalidate请求到事件队列中。UI thread然后从事件队列中取出消息并通知组件进行重绘。</p>

<p>当你的app执行一个比较重的工作时，单线程模式有可能会卡到UI。特别是，在UI线程里面做网络请求操作或者是db查询会严重卡到整个UI。当UI thread被阻塞时，没有事件能够继续被分发，包括绘制事件。那么在用户看来，这样的程序是糟糕的。更糟糕的是，如果UI线程被阻塞超过5秒，程序会就出现ANR的错误提示。那么用户可能会决定推出程序，并对该程序进行卸载。</p>

<p>另外，Andoid的UI组件不是thread-safe的。因此，你不应该在另外一个线程去操控UI组件。有两个原则需要遵守：<br/>
* 不要阻塞UI线程。<br/>
* 不要在UI线程之外访问UI组件。</p>

<h2>Worker threads</h2>

<p>为了实现执行耗时的操作，你应该确保那些动作执行在另外一个线程("background" or "worker" threads)。</p>

<p>例如，下面的代码演示了点击事件后开启另外一个线程来下载并显示图片的操作：<br/>
```java</p>

<pre><code>public void onClick(View v) {
    new Thread(new Runnable() {
        public void run() {
            Bitmap b = loadImageFromNetwork("http://example.com/image.png");
            mImageView.setImageBitmap(b);
        }
    }).start();
}
</code></pre>

<p>```java
上面的例子看起来没有问题，实际上违法了第二条规则：不要在UI线程之外访问UI组件。
Android提供了下面三个方法来解决这个问题：</p>

<ul>
<li>Activity.runOnUiThread(Runnable)</li>
<li>View.post(Runnable)</li>
<li>View.postDelayed(Runnable, long)</li>
</ul>


<p>例如下面就是使用View.post的方式实现的代码示例
```java</p>

<pre><code>public void onClick(View v) {
    new Thread(new Runnable() {
        public void run() {
            final Bitmap bitmap = loadImageFromNetwork("http://example.com/image.png");
            mImageView.post(new Runnable() {
                public void run() {
                    mImageView.setImageBitmap(bitmap);
                }
            });
        }
    }).start();
}
</code></pre>

<p>```java
上面的代码虽然实现了功能，可是当系统变复杂时，会显得不好处理。也许我们可以考虑使用Handler，但是更好的方案也许是使用AsyncTask。</p>

<h2>Using AsyncTask</h2>

<p>关于什么是AsyncTask与如何使用<a href="http://developer.android.com/reference/android/os/AsyncTask.html">AsyncTask</a>，不再赘述。
下面是使用AsyncTask来实现上面的例子：
```java</p>

<pre><code>public void onClick(View v) {
    new DownloadImageTask().execute("http://example.com/image.png");
}

private class DownloadImageTask extends AsyncTask&lt;String, Void, Bitmap&gt; {
    /** The system calls this to perform work in a worker thread and
      * delivers it the parameters given to AsyncTask.execute() */
    protected Bitmap doInBackground(String... urls) {
        return loadImageFromNetwork(urls[0]);
    }

    /** The system calls this to perform work in the UI thread and delivers
      * the result from doInBackground() */
    protected void onPostExecute(Bitmap result) {
        mImageView.setImageBitmap(result);
    }
}
</code></pre>

<p>```java</p>

<h2>Thread-safe methods</h2>

<p>在某些情况下，你实现的一些方法有可能会被不止一个线程中执行到，因此这些方法必须是线程安全的。</p>

<p><strong>在bound service的情况下，回调函数通常都需要是线程安全的。如果IBinder的Client与Server是在同一进程的话，那么被Client调用的方法是执行在Client的线程当中的。然而如果Client是在另外一个进程的话，被调用的方法则是执行在来自系统为Server端维护的一个线程池当中的某个线程中（非UI Thread）。例如，既然Service的onBind()的方法可以被service进程的UI线程所调用执行，那么onBind所返回的对象（Client端）所实现的方法则可以被线程池中的线程所调用执行。因为一个service可以拥有多个client，那么在同一时刻可以有不止一个线程可以占用同一个IBinder的回调函数。所以IBinder的方法必须是线程安全的。</strong></p>

<p>同样的，一个content provider可以接受来自另外一个进程的数据请求。尽管ContentResolver与ContentProvider类隐藏了实现细节，但是ContentProvider所提供的query()，insert()，delete()，update()与getType()都是在content provider进程的线程池中被调用执行的，而不是进程的主线程中。因为那些方法可能同时被多个线程所调用，所以他们都应该是线程安全的。</p>

<h1>Interprocess Communication</h1>

<p>Android提供了为远程过程调用（RPC）提供了一种进程间通信（IPC）的机制。调用发生在activity或者其他组件中，执行却在另外一个进程，最后再把结果返回给调用者。这需要把调用的数据解析成操作系统能够识别的格式，解码，传递，再编码返回。Android提供了IPC交互的实现细节，因此我们只需要专注于定义与实现RPC接口。</p>

<p>为了执行IPC，你的程序必须通过bindService()方法绑定到service上，更多细节，请查看<a href="http://developer.android.com/guide/components/services.html">Services</a>开发指南。</p>

<hr />

<p><strong>文章学习自http://developer.android.com/guide/components/processes-and-threads.html</strong><br/>
<strong>转载请注明出自<a href="http:://kesenhoo.github.com">http://kesenhoo.github.com</a>，谢谢</strong></p>
]]></content>
  </entry>
  
</feed>
