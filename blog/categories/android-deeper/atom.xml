<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android:Deeper | 胡凯]]></title>
  <link href="http://hukai.me/blog/categories/android-deeper/atom.xml" rel="self"/>
  <link href="http://hukai.me/"/>
  <updated>2015-04-14T17:40:14+08:00</updated>
  <id>http://hukai.me/</id>
  <author>
    <name><![CDATA[Kesen Hoo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android性能优化之电量篇]]></title>
    <link href="http://hukai.me/android-performance-battery/"/>
    <updated>2015-04-12T16:49:00+08:00</updated>
    <id>http://hukai.me/android-performance-battery</id>
    <content type="html"><![CDATA[<p><img src="/images/android_performance_course_udacity.jpg" alt="android_performance_course_udacity" /></p>

<p>Google近期在Udacity上发布了<a href="https://www.udacity.com/course/ud825">Android性能优化的在线课程</a>，分别从渲染，运算与内存，电量几个方面介绍了如何去优化性能，这些课程是Google之前在Youtube上发布的<a href="http://hukai.me/android-performance-patterns/">Android性能优化典范</a>专题课程的细化与补充。</p>

<p>下面是电量篇章的学习笔记，部分内容与前面的性能优化典范有重合，欢迎大家一起学习交流！</p>

<h3>1)Understanding Battery Drain</h3>

<p>手机各个硬件模块的耗电量是不一样的，有些模块非常耗电，而有些模块则相对显得耗电量小很多。</p>

<p><img src="/images/android_perf_battery_drain.png" alt="android_perf_battery_drain" /></p>

<p>电量消耗的计算与统计是一件麻烦而且矛盾的事情，记录电量消耗本身也是一个费电量的事情。唯一可行的方案是使用第三方监测电量的设备，这样才能够获取到真实的电量消耗。</p>

<p>当设备处于待机状态时消耗的电量是极少的，以N5为例，打开飞行模式，可以待机接近1个月。可是点亮屏幕，硬件各个模块就需要开始工作，这会需要消耗很多电量。</p>

<p>使用WakeLock或者JobScheduler唤醒设备处理定时的任务之后，一定要及时让设备回到初始状态。每次唤醒蜂窝信号进行数据传递，都会消耗很多电量，它比WiFi等操作更加的耗电。</p>

<!-- More -->


<p><img src="/images/battery_drain_radio.png" alt="battery_drain_radio" /></p>

<h3>2)Battery Historian</h3>

<p><a href="https://developer.android.com/about/versions/android-5.0.html#Power">Battery Historian</a>是Android 5.0开始引入的新API。通过下面的指令，可以得到设备上的电量消耗信息：</p>

<p><code>bash
$ adb shell dumpsys batterystats &gt; xxx.txt  //得到整个设备的电量消耗信息
$ adb shell dumpsys batterystats &gt; com.package.name &gt; xxx.txt //得到指定app相关的电量消耗信息
</code></p>

<p>得到了原始的电量消耗数据之后，我们需要通过Google编写的一个<a href="https://github.com/google/battery-historian">python脚本</a>把数据信息转换成可读性更好的html文件：</p>

<p><code>bash
$ python historian.py xxx.txt &gt; xxx.html
</code></p>

<p>打开这个转换过后的html文件，可以看到类似TraceView生成的列表数据，这里的数据信息量很大，这里就不展开了。</p>

<p><img src="/images/android_perf_battery_historian.png" alt="android_perf_battery_historian" /></p>

<h3>3)Track Battery Status &amp; Battery Manager</h3>

<p>我们可以通过下面的代码来获取手机的当前充电状态：</p>

<p>```java
// It is very easy to subscribe to changes to the battery state, but you can get the current
// state by simply passing null in as your receiver.  Nifty, isn't that?
IntentFilter filter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);
Intent batteryStatus = this.registerReceiver(null, filter);
int chargePlug = batteryStatus.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);
boolean acCharge = (chargePlug == BatteryManager.BATTERY_PLUGGED_AC);
if (acCharge) {</p>

<pre><code>Log.v(LOG_TAG,“The phone is charging!”);
</code></pre>

<p>}
```</p>

<p>在上面的例子演示了如何立即获取到手机的充电状态，得到充电状态信息之后，我们可以有针对性的对部分代码做优化。比如我们可以判断只有当前手机为AC充电状态时
才去执行一些非常耗电的操作。</p>

<p>```java
/<em>*
 * This method checks for power by comparing the current battery state against all possible
 * plugged in states. In this case, a device may be considered plugged in either by USB, AC, or
 * wireless charge. (Wireless charge was introduced in API Level 17.)
 </em>/
private boolean checkForPower() {</p>

<pre><code>// It is very easy to subscribe to changes to the battery state, but you can get the current
// state by simply passing null in as your receiver.  Nifty, isn't that?
IntentFilter filter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);
Intent batteryStatus = this.registerReceiver(null, filter);

// There are currently three ways a device can be plugged in. We should check them all.
int chargePlug = batteryStatus.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);
boolean usbCharge = (chargePlug == BatteryManager.BATTERY_PLUGGED_USB);
boolean acCharge = (chargePlug == BatteryManager.BATTERY_PLUGGED_AC);
boolean wirelessCharge = false;
if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) {
    wirelessCharge = (chargePlug == BatteryManager.BATTERY_PLUGGED_WIRELESS);
}
return (usbCharge || acCharge || wirelessCharge);
</code></pre>

<p>}
```</p>

<h3>4)Wakelock and Battery Drain</h3>

<p>高效的保留更多的电量与不断促使用户使用你的App会消耗电量，这是矛盾的选择题。不过我们可以使用一些更好的办法来平衡两者。</p>

<p>假设你的手机里面装了大量的社交类应用，即使手机处于待机状态，也会经常被这些应用唤醒用来检查同步新的数据信息。Android会不断关闭各种硬件来延长手机的待机时间，首先屏幕会逐渐变暗直至关闭，然后CPU进入睡眠，这一切操作都是为了节约宝贵的电量资源。但是即使在这种睡眠状态下，大多数应用还是会尝试进行工作，他们将不断的唤醒手机。一个最简单的唤醒手机的方法是使用PowerManager.WakeLock的API来保持CPU工作并防止屏幕变暗关闭。这使得手机可以被唤醒，执行工作，然后回到睡眠状态。知道如何获取WakeLock是简单的，可是及时释放WakeLock也是非常重要的，不恰当的使用WakeLock会导致严重错误。例如网络请求的数据返回时间不确定，导致本来只需要10s的事情一直等待了1个小时，这样会使得电量白白浪费了。这也是为何使用带超时参数的wakelock.acquice()方法是很关键的。</p>

<p>但是仅仅设置超时并不足够解决问题，例如设置多长的超时比较合适？什么时候进行重试等等？解决上面的问题，正确的方式可能是使用非精准定时器。通常情况下，我们会设定一个时间进行某个操作，但是动态修改这个时间也许会更好。例如，如果有另外一个程序需要比你设定的时间晚5分钟唤醒，最好能够等到那个时候，两个任务捆绑一起同时进行，这就是非精确定时器的核心工作原理。我们可以定制计划的任务，可是系统如果检测到一个更好的时间，它可以推迟你的任务，以节省电量消耗。</p>

<p><img src="/images/alarmmanager_inexact_wakelock.png" alt="alarmmanager_inexact_wakelock" /></p>

<p>这正是JobScheduler API所做的事情。它会根据当前的情况与任务，组合出理想的唤醒时间，例如等到正在充电或者连接到WiFi的时候，或者集中任务一起执行。我们可以通过这个API实现很多免费的调度算法。</p>

<h3>5)Network and Battery Drain</h3>

<p>下面内容来自官方Training文档中<a href="http://hukai.me/android-training-course-in-chinese/connectivity/efficient-downloads/efficient-network-access.html">高效下载</a>章节关于手机(Radio)蜂窝信号对电量消耗的介绍。</p>

<p>通常情况下，使用3G移动网络传输数据，电量的消耗有三种状态：</p>

<ul>
<li><strong>Full power</strong>: 能量最高的状态，移动网络连接被激活，允许设备以最大的传输速率进行操作。</li>
<li><strong>Low power</strong>: 一种中间状态，对电量的消耗差不多是Full power状态下的50%。</li>
<li><strong>Standby</strong>: 最低的状态，没有数据连接需要传输，电量消耗最少。</li>
</ul>


<p>下图是一个典型的3G Radio State Machine的图示(来自AT&amp;T，详情请点击<a href="http://www.research.att.com/articles/featured_stories/2011_03/201102_Energy_efficient?fbid=SYuI20FzBum">这里</a>):</p>

<p><img src="/images/mobile_radio_state_machine.png" title="Figure 1. Typical 3G wireless radio state machine." alt="mobile_radio_state_machine.png" /></p>

<p><strong>总之，为了减少电量的消耗，在蜂窝移动网络下，最好做到批量执行网络请求，尽量避免频繁的间隔网络请求。</strong></p>

<p>通过前面学习到的Battery Historian我们可以得到设备的电量消耗数据，如果数据中的移动蜂窝网络(Mobile Radio)电量消耗呈现下面的情况，间隔很小，又频繁断断续续的出现，说明电量消耗性能很不好：</p>

<p><img src="/images/android_perf_battery_bad.png" alt="android_perf_battery_bad.png" /></p>

<p>经过优化之后，如果呈现下面的图示，说明电量消耗的性能是良好的：</p>

<p><img src="/images/android_perf_battery_good.png" alt="android_perf_battery_good" /></p>

<p>另外WiFi连接下，网络传输的电量消耗要比移动网络少很多，应该尽量减少移动网络下的数据传输，多在WiFi环境下传输数据。</p>

<p><img src="/images/android_perf_battery_wifi.png" alt="android_perf_battery_wifi" /></p>

<p>那么如何才能够把任务缓存起来，做到批量化执行呢？下面就轮到Job Scheduler出场了。</p>

<h3>6)Using Job Scheduler</h3>

<p>使用<a href="https://developer.android.com/reference/android/app/job/JobScheduler.html">Job Scheduler</a>，应用需要做的事情就是判断哪些任务是不紧急的，可以交给Job Scheduler来处理，Job Scheduler集中处理收到的任务，选择合适的时间，合适的网络，再一起进行执行。</p>

<p>下面是使用Job Scheduler的一段简要示例，需要先有一个JobService：</p>

<p>```java
public class MyJobService extends JobService {</p>

<pre><code>private static final String LOG_TAG = "MyJobService";

@Override
public void onCreate() {
    super.onCreate();
    Log.i(LOG_TAG, "MyJobService created");
}

@Override
public void onDestroy() {
    super.onDestroy();
    Log.i(LOG_TAG, "MyJobService destroyed");
}

@Override
public boolean onStartJob(JobParameters params) {
    // This is where you would implement all of the logic for your job. Note that this runs
    // on the main thread, so you will want to use a separate thread for asynchronous work
    // (as we demonstrate below to establish a network connection).
    // If you use a separate thread, return true to indicate that you need a "reschedule" to
    // return to the job at some point in the future to finish processing the work. Otherwise,
    // return false when finished.
    Log.i(LOG_TAG, "Totally and completely working on job " + params.getJobId());
    // First, check the network, and then attempt to connect.
    if (isNetworkConnected()) {
        new SimpleDownloadTask() .execute(params);
        return true;
    } else {
        Log.i(LOG_TAG, "No connection on job " + params.getJobId() + "; sad face");
    }
    return false;
}

@Override
public boolean onStopJob(JobParameters params) {
    // Called if the job must be stopped before jobFinished() has been called. This may
    // happen if the requirements are no longer being met, such as the user no longer
    // connecting to WiFi, or the device no longer being idle. Use this callback to resolve
    // anything that may cause your application to misbehave from the job being halted.
    // Return true if the job should be rescheduled based on the retry criteria specified
    // when the job was created or return false to drop the job. Regardless of the value
    // returned, your job must stop executing.
    Log.i(LOG_TAG, "Whelp, something changed, so I'm calling it on job " + params.getJobId());
    return false;
}

/**
 * Determines if the device is currently online.
 */
private boolean isNetworkConnected() {
    ConnectivityManager connectivityManager =
            (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);
    NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();
    return (networkInfo != null &amp;&amp; networkInfo.isConnected());
}

/**
 *  Uses AsyncTask to create a task away from the main UI thread. This task creates a
 *  HTTPUrlConnection, and then downloads the contents of the webpage as an InputStream.
 *  The InputStream is then converted to a String, which is logged by the
 *  onPostExecute() method.
 */
private class SimpleDownloadTask extends AsyncTask&lt;JobParameters, Void, String&gt; {

    protected JobParameters mJobParam;

    @Override
    protected String doInBackground(JobParameters... params) {
        // cache system provided job requirements
        mJobParam = params[0];
        try {
            InputStream is = null;
            // Only display the first 50 characters of the retrieved web page content.
            int len = 50;

            URL url = new URL("https://www.google.com");
            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
            conn.setReadTimeout(10000); //10sec
            conn.setConnectTimeout(15000); //15sec
            conn.setRequestMethod("GET");
            //Starts the query
            conn.connect();
            int response = conn.getResponseCode();
            Log.d(LOG_TAG, "The response is: " + response);
            is = conn.getInputStream();

            // Convert the input stream to a string
            Reader reader = null;
            reader = new InputStreamReader(is, "UTF-8");
            char[] buffer = new char[len];
            reader.read(buffer);
            return new String(buffer);

        } catch (IOException e) {
            return "Unable to retrieve web page.";
        }
    }

    @Override
    protected void onPostExecute(String result) {
        jobFinished(mJobParam, false);
        Log.i(LOG_TAG, result);
    }
}
</code></pre>

<p>}
```</p>

<p>然后模拟通过点击Button触发N个任务，交给JobService来处理</p>

<p>```java
public class FreeTheWakelockActivity extends ActionBarActivity {</p>

<pre><code>public static final String LOG_TAG = "FreeTheWakelockActivity";

TextView mWakeLockMsg;
ComponentName mServiceComponent;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_wakelock);

    mWakeLockMsg = (TextView) findViewById(R.id.wakelock_txt);
    mServiceComponent = new ComponentName(this, MyJobService.class);
    Intent startServiceIntent = new Intent(this, MyJobService.class);
    startService(startServiceIntent);

    Button theButtonThatWakelocks = (Button) findViewById(R.id.wakelock_poll);
    theButtonThatWakelocks.setText(R.string.poll_server_button);

    theButtonThatWakelocks.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
                pollServer();
        }
    });
}

/**
 * This method polls the server via the JobScheduler API. By scheduling the job with this API,
 * your app can be confident it will execute, but without the need for a wake lock. Rather, the
 * API will take your network jobs and execute them in batch to best take advantage of the
 * initial network connection cost.
 *
 * The JobScheduler API works through a background service. In this sample, we have
 * a simple service in MyJobService to get you started. The job is scheduled here in
 * the activity, but the job itself is executed in MyJobService in the startJob() method. For
 * example, to poll your server, you would create the network connection, send your GET
 * request, and then process the response all in MyJobService. This allows the JobScheduler API
 * to invoke your logic without needed to restart your activity.
 *
 * For brevity in the sample, we are scheduling the same job several times in quick succession,
 * but again, try to consider similar tasks occurring over time in your application that can
 * afford to wait and may benefit from batching.
 */
public void pollServer() {
    JobScheduler scheduler = (JobScheduler) getSystemService(Context.JOB_SCHEDULER_SERVICE);
    for (int i=0; i&lt;10; i++) {
        JobInfo jobInfo = new JobInfo.Builder(i, mServiceComponent)
                .setMinimumLatency(5000) // 5 seconds
                .setOverrideDeadline(60000) // 60 seconds (for brevity in the sample)
                .setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY) // WiFi or data connections
                .build();

        mWakeLockMsg.append("Scheduling job " + i + "!\n");
        scheduler.schedule(jobInfo);
    }
}
</code></pre>

<p>}
```</p>

<p><strong>Notes:</strong>关于更多电量优化，还有一篇文章，请点击<a href="http://developer.android.com/training/efficient-downloads/index.html">这里</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android性能优化之内存篇]]></title>
    <link href="http://hukai.me/android-performance-memory/"/>
    <updated>2015-04-12T14:51:00+08:00</updated>
    <id>http://hukai.me/android-performance-memory</id>
    <content type="html"><![CDATA[<p><img src="/images/android_performance_course_udacity.jpg" alt="" /></p>

<p>Google近期在Udacity上发布了<a href="https://www.udacity.com/course/ud825">Android性能优化的在线课程</a>，分别从渲染，运算与内存，电量几个方面介绍了如何去优化性能，这些课程是Google之前在Youtube上发布的<a href="http://hukai.me/android-performance-patterns/">Android性能优化典范</a>专题课程的细化与补充。</p>

<p>下面是内存篇章的学习笔记，部分内容与前面的性能优化典范有重合，欢迎大家一起学习交流！</p>

<h3>1)Memory, GC, and Performance</h3>

<p>众所周知，与C/C++需要通过手动编码来申请以及释放内存有所不同，Java拥有GC的机制。Android系统里面有一个<strong>Generational Heap Memory</strong>的模型，系统会根据内存中不同的内存数据类型分别执行不同的GC操作。例如，最近刚分配的对象会放在Young Generation区域，这个区域的对象通常都是会快速被创建并且很快被销毁回收的，同时这个区域的GC操作速度也是比Old Generation区域的GC操作速度更快的。</p>

<p><img src="/images/memory_mode_generation.png" alt="" /></p>

<p>除了速度差异之外，执行GC操作的时候，所有线程的任何操作都会需要暂停，等待GC操作完成之后，其他操作才能够继续运行。</p>

<!-- More -->


<p><img src="/images/gc_event_thread_stop.png" alt="" /></p>

<p>通常来说，单个的GC并不会占用太多时间，但是大量不停的GC操作则会显著占用帧间隔时间(16ms)。如果在帧间隔时间里面做了过多的GC操作，那么自然其他类似计算，渲染等操作的可用时间就变得少了。</p>

<h3>2)Memory Monitor Walkthrough</h3>

<p>Android Studio中的Memory Monitor可以很好的帮助我们查看程序的内存使用情况。</p>

<p><img src="/images/memory_monitor_overview.png" alt="" /></p>

<p><img src="/images/memory_monitor_free_allocation.png" alt="" /></p>

<p><img src="/images/memory_monitor_gc_event.png" alt="" /></p>

<h3>3)Memory Leaks</h3>

<p>内存泄漏表示的是不再用到的对象因为被错误引用而无法进行回收。</p>

<p><img src="/images/android_perf_memory_leak.png" alt="" /></p>

<p>发生内存泄漏会导致Memory Generation中的剩余可用Heap Size越来越小，这样会导致频繁触发GC，更进一步引起性能问题。</p>

<p>举例内存泄漏，下面<code>init()</code>方法来自某个自定义View：</p>

<p>```java</p>

<pre><code>private void init() {
ListenerCollector collector = new ListenerCollector();
collector.setListener(this, mListener);
</code></pre>

<p>}
```</p>

<p>上面的例子容易存在内存泄漏，如果activity因为设备翻转而重新创建，自定义的View会自动重新把新创建出来的mListener给绑定到ListenerCollector中，但是当activity被销毁的时候，mListener却无法被回收了。</p>

<h3>4)Heap Viewer Walkthrough</h3>

<p>下图演示了Android Tools里面的Heap Viewer的功能，我们可以看到当前进程中的Heap Size的情况，分别有哪些类型的数据，占比是多少。</p>

<p><img src="/images/android_perf_memory_heap_viewer.png" alt="" /></p>

<h3>5)Understanding Memory Churn</h3>

<p><strong>Memory Churn内存抖动</strong>，内存抖动是因为在短时间内大量的对象被创建又马上被释放。瞬间产生大量的对象会严重占用Young Generation的内存区域，当达到阀值，剩余空间不够的时候，会触发GC从而导致刚产生的对象又很快被回收。即使每次分配的对象占用了很少的内存，但是他们叠加在一起会增加Heap的压力，从而触发更多其他类型的GC。这个操作有可能会影响到帧率，并使得用户感知到性能问题。</p>

<p><img src="/images/gc_overtime.png" alt="" /></p>

<p>解决上面的问题有简洁直观方法，如果你在<strong>Memory Monitor</strong>里面查看到短时间发生了多次内存的涨跌，这意味着很有可能发生了内存抖动。</p>

<p><img src="/images/memory_monitor_gc.png" alt="" /></p>

<p>同时我们还可以通过<strong>Allocation Tracker</strong>来查看在短时间内，同一个栈中不断进出的相同对象。这是内存抖动的典型信号之一。</p>

<p>当你大致定位问题之后，接下去的问题修复也就显得相对直接简单了。例如，你需要避免在for循环里面分配对象占用内存，需要尝试把对象的创建移到循环体之外，自定义View中的onDraw方法也需要引起注意，每次屏幕发生绘制以及动画执行过程中，onDraw方法都会被调用到，避免在onDraw方法里面执行复杂的操作，避免创建对象。对于那些无法避免需要创建对象的情况，我们可以考虑对象池模型，通过对象池来解决频繁创建与销毁的问题，但是这里需要注意结束使用之后，需要手动释放对象池中的对象。</p>

<h3>6)Allocation Tracker</h3>

<p>关于Allocation Tracker工具的使用，不展开了，参考下面的链接：</p>

<ul>
<li><a href="http://developer.android.com/tools/debugging/ddms.html#alloc">http://developer.android.com/tools/debugging/ddms.html#alloc</a></li>
<li><a href="http://android-developers.blogspot.com/2009/02/track-memory-allocations.html">http://android-developers.blogspot.com/2009/02/track-memory-allocations.html</a></li>
</ul>


<h3>7)Improve Your Code To Reduce Churn</h3>

<p>下面演示一个例子，如何通过修改代码来避免内存抖动。优化之前的内存检测图：</p>

<p><img src="/images/android_perf_memory_churn_1.png" alt="" /></p>

<p>定位代码之后，修复了String拼接的问题：</p>

<p><img src="/images/android_perf_memory_churn_code.png" alt="" /></p>

<p>优化之后的内存监测图：</p>

<p><img src="/images/android_perf_memory_churn_2.png" alt="" /></p>

<h3>8)Recap</h3>

<p>上面提到了三种测量内存的工具，下面再简要概括一下他们各自的特点：</p>

<ul>
<li><strong>Memory Monitor：</strong>跟踪整个app的内存变化情况。</li>
<li><strong>Heap Viewer：</strong>查看当前内存快照，便于对比分析哪些对象有可能发生了泄漏。</li>
<li><strong>Allocation Tracker：</strong>追踪内存对象的来源。</li>
</ul>


<p><strong>Notes:</strong>关于更多内存优化，这里还有一篇文章，请点击<a href="http://hukai.me/android-training-managing_your_app_memory/">这里</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android性能优化之运算篇]]></title>
    <link href="http://hukai.me/android-performance-compute/"/>
    <updated>2015-04-12T13:50:00+08:00</updated>
    <id>http://hukai.me/android-performance-compute</id>
    <content type="html"><![CDATA[<p><img src="/images/android_performance_course_udacity.jpg" alt="" /></p>

<p>Google近期在Udacity上发布了<a href="https://www.udacity.com/course/ud825">Android性能优化的在线课程</a>，分别从渲染，运算与内存，电量几个方面介绍了如何去优化性能，这些课程是Google之前在Youtube上发布的<a href="http://hukai.me/android-performance-patterns/">Android性能优化典范</a>专题课程的细化与补充。</p>

<p>下面是运算篇章的学习笔记，部分内容与前面的性能优化典范有重合，欢迎大家一起学习交流！</p>

<h3>1)Intro to Compute and Memory Problems</h3>

<p>Android中的Java代码会需要经过编译优化再执行的过程。代码的不同写法会影响到Java编译器的优化效率。例如for循环的不同写法就会对编译器优化这段代码产生不同的效率，当程序中包含大量这种可优化的代码的时候，运算性能就会出现问题。想要知道如何优化代码的运算性能就需要知道代码在硬件层的执行差异。</p>

<h3>2)Slow Function Performance</h3>

<p>如果你写了一段代码，它的执行效率比想象中的要差很多。我们需要知道有哪些因素有可能影响到这段代码的执行效率。例如：比较两个float数值大小的执行时间是int数值的4倍左右。这是因为CPU的运算架构导致的，如下图所示：</p>

<p><img src="/images/android_perf_compute_float_int.png" alt="" /></p>

<p>虽然现代的CPU架构得到了很大的提升，也许并不存在上面所示的那么大的差异，但是这个例子说明了代码写法上的差异会对运算性能产生很大的影响。</p>

<!-- More -->


<p>通常来说有两类运行效率差的情况：第1种是相对执行时间长的方法，我们可以很轻松的找到这些方法并做一定的优化。第2种是执行时间短，但是执行频次很高的方法，因为执行次数多，累积效应下就会对性能产生很大的影响。</p>

<p>修复这些细节效率问题，需要使用Android SDK提供的工具，进行仔细的测量，然后再进行微调修复。</p>

<h3>3)Traceview Walkthrough</h3>

<p>通过Android Studio打开里面的Android Device Monitor，切换到DDMS窗口，点击左边栏上面想要跟踪的进程，再点击上面的Start Method Tracing的按钮，如下图所示：</p>

<p><img src="/images/android_perf_compute_traceview.png" alt="" /></p>

<p>启动跟踪之后，再操控app，做一些你想要跟踪的事件，例如滑动listview，点击某些视图进入另外一个页面等等。操作完之后，回到Android Device Monitor，再次点击Method Tracing的按钮停止跟踪。此时工具会为刚才的操作生成TraceView的详细视图。</p>

<p><img src="/images/android_perf_compute_traceview_2.png" alt="" /></p>

<p>关于TraceView中详细数据如何查看，这里不展开了，有很多文章介绍过。</p>

<h3>4)Batching and Caching</h3>

<p>为了提升运算性能，这里介绍2个非常重要的技术，Batching与Caching。</p>

<p><strong>Batching</strong>是在真正执行运算操作之前对数据进行批量预处理，例如你需要有这样一个方法，它的作用是查找某个值是否存在与于一堆数据中。假设一个前提，我们会先对数据做排序，然后使用二分查找法来判断值是否存在。我们先看第一种情况，下图中存在着多次重复的排序操作。</p>

<p><img src="/images/android_perf_compute_batching_1.png" alt="" /></p>

<p>在上面的那种写法下，如果数据的量级并不大的话，应该还可以接受，可是如果数据集非常大，就会有严重的效率问题。那么我们看下改进的写法，把排序的操作打包绑定只执行一次：</p>

<p><img src="/images/android_perf_compute_batching_2.png" alt="" /></p>

<p>上面就是Batching的一种示例：把重复的操作拎出来，打包只执行一次。</p>

<p><strong>Caching</strong>的理念很容易理解，在很多方面都有体现，下面举一个for循环的例子：</p>

<p><img src="/images/android_perf_compute_caching.png" alt="" /></p>

<p>上面这2种基础技巧非常实用，积极恰当的使用能够显著提升运算性能。</p>

<h3>5)Blocking the UI Thread</h3>

<p>提升代码的运算效率是改善性能的一方面，让代码执行在哪个线程也同样很重要。我们都知道Android的Main Thread也是UI Thread，它需要承担用户的触摸事件的反馈，界面视图的渲染等操作。这就意味着，我们不能在Main Thread里面做任何非轻量级的操作，类似I/O操作会花费大量时间，这很有可能会导致界面渲染发生丢帧的现象，甚至有可能导致ANR。防止这些问题的解决办法就是把那些可能有性能问题的代码移到非UI线程进行操作。</p>

<h3>6)Container Performance</h3>

<p>另外一个我们需要注意的运算性能问题是基础算法的合理选择，例如冒泡排序与快速排序的性能差异：</p>

<p><img src="/images/android_perf_compute_container.png" alt="" /></p>

<p>避免我们重复造轮子，Java提供了很多现成的容器，例如Vector，ArrayList，LinkedList，HashMap等等，在Android里面还有新增加的SparseArray等，我们需要了解这些基础容器的性能差异以及适用场景。这样才能够选择合适的容器，达到最佳的性能。</p>

<p><img src="/images/android_perf_compute_container_2.png" alt="" /></p>

<p><strong>Notes:</strong>关于更多代码优化的小技巧，请点击<a href="http://hukai.me/android-training-performance-tips/">这里</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android性能优化之渲染篇]]></title>
    <link href="http://hukai.me/android-performance-render/"/>
    <updated>2015-04-11T22:16:00+08:00</updated>
    <id>http://hukai.me/android-performance-render</id>
    <content type="html"><![CDATA[<p><img src="/images/android_performance_course_udacity.jpg" alt="" /></p>

<p>Google近期在Udacity上发布了<a href="https://www.udacity.com/course/ud825">Android性能优化的在线课程</a>，目前有三个篇章，分别从渲染，运算与内存，电量三个方面介绍了如何去优化性能，这些课程是Google之前在Youtube上发布的<a href="http://hukai.me/android-performance-patterns/">Android性能优化典范</a>专题课程的细化与补充。</p>

<p>下面是渲染篇章的学习笔记，部分内容和前面的性能优化典范有重合，欢迎大家一起学习交流！</p>

<h3>1)Why Rendering Performance Matters</h3>

<p>现在有不少App为了达到很华丽的视觉效果，会需要在界面上层叠很多的视图组件，但是这会很容易引起性能问题。如何平衡Design与Performance就很需要智慧了。</p>

<h3>2)Defining 'Jank'</h3>

<p>大多数手机的屏幕刷新频率是60hz，如果在1000/60=16.67ms内没有办法把这一帧的任务执行完毕，就会发生丢帧的现象。丢帧越多，用户感受到的卡顿情况就越严重。</p>

<p><img src="/images/android_performance_course_drop_frame.png" alt="" /></p>

<h3>3)Rendering Pipeline: Common Problems</h3>

<p>渲染操作通常依赖于两个核心组件：CPU与GPU。CPU负责包括Measure，Layout，Record，Execute的计算操作，GPU负责Rasterization(栅格化)操作。CPU通常存在的问题的原因是存在非必需的视图组件，它不仅仅会带来重复的计算操作，而且还会占用额外的GPU资源。</p>

<!-- More -->


<p><img src="/images/android_performance_course_render_problems.jpg" alt="" /></p>

<h3>4)Android UI and the GPU</h3>

<p>了解Android是如何利用GPU进行画面渲染有助于我们更好的理解性能问题。一个很直接的问题是：activity的画面是如何绘制到屏幕上的？那些复杂的XML布局文件又是如何能够被识别并绘制出来的？</p>

<p><img src="/images/gpu_rasterization.png" alt="" /></p>

<p><strong>Resterization栅格化</strong>是绘制那些Button，Shape，Path，String，Bitmap等组件最基础的操作。它把那些组件拆分到不同的像素上进行显示。这是一个很费时的操作，GPU的引入就是为了加快栅格化的操作。</p>

<p>CPU负责把UI组件计算成Polygons，Texture纹理，然后交给GPU进行栅格化渲染。</p>

<p><img src="/images/gpu_cpu_rasterization.png" alt="" /></p>

<p>然而每次从CPU转移到GPU是一件很麻烦的事情，所幸的是OpenGL ES可以把那些需要渲染的纹理Hold在GPU Memory里面，在下次需要渲染的时候直接进行操作。所以如果你更新了GPU所hold住的纹理内容，那么之前保存的状态就丢失了。</p>

<p>在Android里面那些由主题所提供的资源，例如Bitmaps，Drawables都是一起打包到统一的Texture纹理当中，然后再传递到GPU里面，这意味着每次你需要使用这些资源的时候，都是直接从纹理里面进行获取渲染的。当然随着UI组件的越来越丰富，有了更多演变的形态。例如显示图片的时候，需要先经过CPU的计算加载到内存中，然后传递给GPU进行渲染。文字的显示比较复杂，需要先经过CPU换算成纹理，然后交给GPU进行渲染，返回到CPU绘制单个字符的时候，再重新引用经过GPU渲染的内容。动画则存在一个更加复杂的操作流程。</p>

<p>为了能够使得App流畅，我们需要在每帧16ms以内处理完所有的CPU与GPU的计算，绘制，渲染等等操作。</p>

<h3>5)GPU Problem: Overdraw</h3>

<p>Overdraw(过度绘制)描述的是屏幕上的某个像素在同一帧的时间内被绘制了多次。在多层次重叠的UI结构里面，如果不可见的UI也在做绘制的操作，会导致某些像素区域被绘制了多次。这样就会浪费大量的CPU以及GPU资源。</p>

<p><img src="/images/overdraw_hidden_view.png" alt="" /></p>

<p>当设计上追求更华丽的视觉效果的时候，我们就容易陷入采用复杂的多层次重叠视图来实现这种视觉效果的怪圈。这很容易导致大量的性能问题，为了获得最佳的性能，我们必须尽量减少Overdraw的情况发生。</p>

<p>幸运的是，我们可以通过手机设置里面的开发者选项，打开Show GPU Overdraw的选项，观察UI上的Overdraw情况。</p>

<p><img src="/images/overdraw_options_view.png" alt="" /></p>

<p>蓝色，淡绿，淡红，深红代表了4种不同程度的Overdraw情况，我们的目标就是尽量减少红色Overdraw，看到更多的蓝色区域。</p>

<h3>6)Visualize and Fix Overdraw - Quiz &amp; Solution</h3>

<p>这里举了一个例子，通过XML文件可以看到有好几处非必需的background。通过把XML中非必需的background移除之后，可以显著减少布局的过度绘制。其中一个比较有意思的地方是：针对ListView中的Avatar ImageView的设置，在getView的代码里面，判断是否获取到对应的Bitmap，在获取到Avatar的图像之后，把ImageView的Background设置为Transparent，只有当图像没有获取到的时候才设置对应的Background占位图片，这样可以避免因为给Avatar设置背景图而导致的过度渲染。</p>

<p><img src="/images/android_perf_course_overdraw_compare.png" alt="" /></p>

<p>总结一下，优化步骤如下：</p>

<ul>
<li>移除Window默认的Background</li>
<li>移除XML布局文件中非必需的Background</li>
<li>按需显示占位背景图片</li>
</ul>


<h3>7)ClipRect &amp; QuickReject</h3>

<p>前面有提到过，对不可见的UI组件进行绘制更新会导致Overdraw。例如Nav Drawer从前置可见的Activity滑出之后，如果还继续绘制那些在Nav Drawer里面不可见的UI组件，这就导致了Overdraw。为了解决这个问题，Android系统会通过避免绘制那些完全不可见的组件来尽量减少Overdraw。那些Nav Drawer里面不可见的View就不会被执行浪费资源。</p>

<p><img src="/images/overdraw_invisible.png" alt="" /></p>

<p>但是不幸的是，对于那些过于复杂的自定义的View(通常重写了onDraw方法)，Android系统无法检测在onDraw里面具体会执行什么操作，系统无法监控并自动优化，也就无法避免Overdraw了。但是我们可以通过<a href="http://developer.android.com/reference/android/graphics/Canvas.html">canvas.clipRect()</a>来帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视。这个API可以很好的帮助那些有多组重叠组件的自定义View来控制显示的区域。同时clipRect方法还可以帮助节约CPU与GPU资源，在clipRect区域之外的绘制指令都不会被执行，那些部分内容在矩形区域内的组件，仍然会得到绘制。</p>

<p><img src="/images/overdraw_reduce_cpu_gpu.png" alt="" /></p>

<p>除了clipRect方法之外，我们还可以使用<a href="http://developer.android.com/reference/android/graphics/Canvas.html">canvas.quickreject()</a>来判断是否没和某个矩形相交，从而跳过那些非矩形区域内的绘制操作。</p>

<h3>8)Apply clipRect and quickReject - Quiz &amp; Solution</h3>

<p><img src="/images/android_perf_course_clip_1.png" alt="" /></p>

<p>上面的示例图中显示了一个自定义的View，主要效果是呈现多张重叠的卡片。这个View的onDraw方法如下图所示：</p>

<p><img src="/images/android_perf_course_clip_3.png" alt="" /></p>

<p>打开开发者选项中的显示过度渲染，可以看到我们这个自定义的View部分区域存在着过度绘制。那么是什么原因导致过度绘制的呢？</p>

<p><img src="/images/android_perf_course_clip_2.png" alt="" /></p>

<h3>9)Fixing Overdraw with Canvas API</h3>

<p>下面的代码显示了如何通过clipRect来解决自定义View的过度绘制，提高自定义View的绘制性能：</p>

<p><img src="/images/android_perf_course_clip_code_compare.png" alt="" /></p>

<p>下面是优化过后的效果：</p>

<p><img src="/images/android_perf_course_clip_result.png" alt="" /></p>

<h3>10)Layouts, Invalidations and Perf</h3>

<p>Android需要把XML布局文件转换成GPU能够识别并绘制的对象。这个操作是在<strong>DisplayList</strong>的帮助下完成的。DisplayList持有所有将要交给GPU绘制到屏幕上的数据信息。</p>

<p>在某个View第一次需要被渲染时，Display List会因此被创建，当这个View要显示到屏幕上时，我们会执行GPU的绘制指令来进行渲染。</p>

<p>如果View的Property属性发生了改变（例如移动位置），我们就仅仅需要Execute Display List就够了。</p>

<p><img src="/images/android_perf_course_displaylist_execute.png" alt="" /></p>

<p>然而如果你修改了View中的某些可见组件的内容，那么之前的DisplayList就无法继续使用了，我们需要重新创建一个DisplayList并重新执行渲染指令更新到屏幕上。</p>

<p><img src="/images/android_perf_course_displaylist_invalidation.png" alt="" /></p>

<p>请注意：任何时候View中的绘制内容发生变化时，都会需要重新创建DisplayList，渲染DisplayList，更新到屏幕上等一系列操作。这个流程的表现性能取决于你的View的复杂程度，View的状态变化以及渲染管道的执行性能。举个例子，假设某个Button的大小需要增大到目前的两倍，在增大Button大小之前，需要通过父View重新计算并摆放其他子View的位置。修改View的大小会触发整个HierarcyView的重新计算大小的操作。如果是修改View的位置则会触发HierarchView重新计算其他View的位置。如果布局很复杂，这就会很容易导致严重的性能问题。</p>

<p><img src="/images/android_perf_course_displaylist_kick_off.png" alt="" /></p>

<h3>11)Hierarchy Viewer: Walkthrough</h3>

<p>Hierarchy Viewer可以很直接的呈现布局的层次关系，视图组件的各种属性。
我们可以通过红，黄，绿三种不同的颜色来区分布局的Measure，Layout，Executive的相对性能表现如何。</p>

<h3>12)Nested Hierarchies and Performance</h3>

<p>提升布局性能的关键点是尽量保持布局层级的扁平化，避免出现重复的嵌套布局。例如下面的例子，有2行显示相同内容的视图，分别用两种不同的写法来实现，他们有着不同的层级。</p>

<p><img src="/images/android_perf_course_hierarchy_1.png" alt="" /></p>

<p><img src="/images/android_perf_course_hierarchy_2.png" alt="" /></p>

<p>下图显示了使用2种不同的写法，在Hierarchy Viewer上呈现出来的性能测试差异：</p>

<p><img src="/images/android_perf_course_hierarchy_3.png" alt="" /></p>

<h3>13)Optimizing Your Layout</h3>

<p>下图举例演示了如何优化ListItem的布局，通过RelativeLayout替代旧方案中的嵌套LinearLayout来优化布局。</p>

<p><img src="/images/android_perf_course_hierarchy_4.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android性能优化典范]]></title>
    <link href="http://hukai.me/android-performance-patterns/"/>
    <updated>2015-01-17T19:42:00+08:00</updated>
    <id>http://hukai.me/android-performance-patterns</id>
    <content type="html"><![CDATA[<p><img src="/images/android_perf_patterns.png" alt="" />
2015新年伊始，Google发布了关于<a href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE">Android性能优化典范的专题</a>，一共16个短视频，每个3-5分钟，帮助开发者创建更快更优秀的Android App。课程专题不仅仅介绍了Android系统中有关性能问题的底层工作原理，同时也介绍了如何通过工具来找出性能问题以及提升性能的建议。主要从三个方面展开，Android的渲染机制，内存与GC，电量优化。下面是对这些问题和建议的总结梳理。</p>

<h2>0)Render Performance</h2>

<p>大多数用户感知到的卡顿等性能问题的最主要根源都是因为渲染性能。从设计师的角度，他们希望App能够有更多的动画，图片等时尚元素来实现流畅的用户体验。但是Android系统很有可能无法及时完成那些复杂的界面渲染操作。Android系统每隔16ms发出VSYNC信号，触发对UI进行渲染，如果每次渲染都成功，这样就能够达到流畅的画面所需要的60fps，为了能够实现60fps，这意味着程序的大多数操作都必须在16ms内完成。</p>

<p><img src="/images/draw_per_16ms.png" alt="" /></p>

<!-- More -->


<p>如果你的某个操作花费时间是24ms，系统在得到VSYNC信号的时候就无法进行正常渲染，这样就发生了丢帧现象。那么用户在32ms内看到的会是同一帧画面。</p>

<p><img src="/images/vsync_over_draw.png" alt="" /></p>

<p>用户容易在UI执行动画或者滑动ListView的时候感知到卡顿不流畅，是因为这里的操作相对复杂，容易发生丢帧的现象，从而感觉卡顿。有很多原因可以导致丢帧，也许是因为你的layout太过复杂，无法在16ms内完成渲染，有可能是因为你的UI上有层叠太多的绘制单元，还有可能是因为动画执行的次数过多。这些都会导致CPU或者GPU负载过重。</p>

<p>我们可以通过一些工具来定位问题，比如可以使用HierarchyViewer来查找Activity中的布局是否过于复杂，也可以使用手机设置里面的开发者选项，打开Show GPU Overdraw等选项进行观察。你还可以使用TraceView来观察CPU的执行情况，更加快捷的找到性能瓶颈。</p>

<h2>1)Understanding Overdraw</h2>

<p>Overdraw(过度绘制)描述的是屏幕上的某个像素在同一帧的时间内被绘制了多次。在多层次的UI结构里面，如果不可见的UI也在做绘制的操作，这就会导致某些像素区域被绘制了多次。这就浪费大量的CPU以及GPU资源。</p>

<p><img src="/images/overdraw_hidden_view.png" alt="" /></p>

<p>当设计上追求更华丽的视觉效果的时候，我们就容易陷入采用越来越多的层叠组件来实现这种视觉效果的怪圈。这很容易导致大量的性能问题，为了获得最佳的性能，我们必须尽量减少Overdraw的情况发生。</p>

<p>幸运的是，我们可以通过手机设置里面的开发者选项，打开Show GPU Overdraw的选项，可以观察UI上的Overdraw情况。</p>

<p><img src="/images/overdraw_options_view.png" alt="" /></p>

<p>蓝色，淡绿，淡红，深红代表了4种不同程度的Overdraw情况，我们的目标就是尽量减少红色Overdraw，看到更多的蓝色区域。</p>

<p>Overdraw有时候是因为你的UI布局存在大量重叠的部分，还有的时候是因为非必须的重叠背景。例如某个Activity有一个背景，然后里面的Layout又有自己的背景，同时子View又分别有自己的背景。仅仅是通过移除非必须的背景图片，这就能够减少大量的红色Overdraw区域，增加蓝色区域的占比。这一措施能够显著提升程序性能。</p>

<h2>2)Understanding VSYNC</h2>

<p>为了理解App是如何进行渲染的，我们必须了解手机硬件是如何工作，那么就必须理解什么是<em>VSYNC</em>。</p>

<p>在讲解VSYNC之前，我们需要了解两个相关的概念：</p>

<ul>
<li>Refresh Rate：代表了屏幕在一秒内刷新屏幕的次数，这取决于硬件的固定参数，例如60Hz。</li>
<li>Frame Rate：代表了GPU在一秒内绘制操作的帧数，例如30fps，60fps。</li>
</ul>


<p>GPU会获取图形数据进行渲染，然后硬件负责把渲染后的内容呈现到屏幕上，他们两者不停的进行协作。</p>

<p><img src="/images/vsync_gpu_hardware.png" alt="" /></p>

<p>不幸的是，刷新频率和帧率并不是总能够保持相同的节奏。如果发生帧率与刷新频率不一致的情况，就会容易出现<strong>Tearing</strong>的现象(画面上下两部分显示内容发生断裂，来自不同的两帧数据发生重叠)。</p>

<p><img src="/images/vsync_gpu_hardware_not_sync.png" alt="" /></p>

<p><img src="/images/vsync_buffer.png" alt="" /></p>

<p>理解图像渲染里面的双重与三重缓存机制，这个概念比较复杂，请移步查看这里：<a href="http://source.android.com/devices/graphics/index.html">http://source.android.com/devices/graphics/index.html</a>，还有这里<a href="http://article.yeeyan.org/view/37503/304664">http://article.yeeyan.org/view/37503/304664</a>。</p>

<p>通常来说，帧率超过刷新频率只是一种理想的状况，在超过60fps的情况下，GPU所产生的帧数据会因为等待VSYNC的刷新信息而被Hold住，这样能够保持每次刷新都有实际的新的数据可以显示。但是我们遇到更多的情况是帧率小于刷新频率。</p>

<p><img src="/images/vsync_gpu_hardware_not_sync2.png" alt="" /></p>

<p>在这种情况下，某些帧显示的画面内容就会与上一帧的画面相同。糟糕的事情是，帧率从超过60fps突然掉到60fps以下，这样就会发生<strong>LAG</strong>，<strong>JANK</strong>，<strong>HITCHING</strong>等卡顿掉帧的不顺滑的情况。这也是用户感受不好的原因所在。</p>

<h2>3)Tool:Profile GPU Rendering</h2>

<p>性能问题如此的麻烦，幸好我们可以有工具来进行调试。打开手机里面的开发者选项，选择Profile GPU Rendering，选中On screen as bars的选项。</p>

<p><img src="/images/tools_gpu_profile_rendering.png" alt="" /></p>

<p>选择了这样以后，我们可以在手机画面上看到丰富的GPU绘制图形信息，分别关于StatusBar，NavBar，激活的程序Activity区域的GPU Rending信息。</p>

<p><img src="/images/tools_gpu_profile_rendering_graphic_activity.png" alt="" /></p>

<p>随着界面的刷新，界面上会滚动显示垂直的柱状图来表示每帧画面所需要渲染的时间，柱状图越高表示花费的渲染时间越长。</p>

<p><img src="/images/tools_gpu_rendering_bar.png" alt="" /></p>

<p>中间有一根绿色的横线，代表16ms，我们需要确保每一帧花费的总时间都低于这条横线，这样才能够避免出现卡顿的问题。</p>

<p><img src="/images/tools_gpu_profile_three_color.png" alt="" /></p>

<p>每一条柱状线都包含三部分，蓝色代表测量绘制Display List的时间，红色代表OpenGL渲染Display List所需要的时间，黄色代表CPU等待GPU处理的时间。</p>

<h2>4)Why 60fps?</h2>

<p>我们通常都会提到60fps与16ms，可是知道为何会是以程序是否达到60fps来作为App性能的衡量标准吗？这是因为人眼与大脑之间的协作无法感知超过60fps的画面更新。</p>

<p>12fps大概类似手动快速翻动书籍的帧率，这明显是可以感知到不够顺滑的。24fps使得人眼感知的是连续线性的运动，这其实是归功于运动模糊的效果。24fps是电影胶圈通常使用的帧率，因为这个帧率已经足够支撑大部分电影画面需要表达的内容，同时能够最大的减少费用支出。但是低于30fps是无法顺畅表现绚丽的画面内容的，此时就需要用到60fps来达到想要的效果，当然超过60fps是没有必要的。</p>

<p>开发app的性能目标就是保持60fps，这意味着每一帧你只有16ms=1000/60的时间来处理所有的任务。</p>

<h2>5)Android, UI and the GPU</h2>

<p>了解Android是如何利用GPU进行画面渲染有助于我们更好的理解性能问题。那么一个最实际的问题是：activity的画面是如何绘制到屏幕上的？那些复杂的XML布局文件又是如何能够被识别并绘制出来的？</p>

<p><img src="/images/gpu_rasterization.png" alt="" /></p>

<p><strong>Resterization栅格化</strong>是绘制那些Button，Shape，Path，String，Bitmap等组件最基础的操作。它把那些组件拆分到不同的像素上进行显示。这是一个很费时的操作，GPU的引入就是为了加快栅格化的操作。</p>

<p>CPU负责把UI组件计算成Polygons，Texture纹理，然后交给GPU进行栅格化渲染。</p>

<p><img src="/images/gpu_cpu_rasterization.png" alt="" /></p>

<p>然而每次从CPU转移到GPU是一件很麻烦的事情，所幸的是OpenGL ES可以把那些需要渲染的纹理Hold在GPU Memory里面，在下次需要渲染的时候直接进行操作。所以如果你更新了GPU所hold住的纹理内容，那么之前保存的状态就丢失了。</p>

<p>在Android里面那些由主题所提供的资源，例如Bitmaps，Drawables都是一起打包到统一的Texture纹理当中，然后再传递到GPU里面，这意味着每次你需要使用这些资源的时候，都是直接从纹理里面进行获取渲染的。当然随着UI组件的越来越丰富，有了更多演变的形态。例如显示图片的时候，需要先经过CPU的计算加载到内存中，然后传递给GPU进行渲染。文字的显示更加复杂，需要先经过CPU换算成纹理，然后再交给GPU进行渲染，回到CPU绘制单个字符的时候，再重新引用经过GPU渲染的内容。动画则是一个更加复杂的操作流程。</p>

<p>为了能够使得App流畅，我们需要在每一帧16ms以内处理完所有的CPU与GPU计算，绘制，渲染等等操作。</p>

<h2>6)Invalidations, Layouts, and Performance</h2>

<p>顺滑精妙的动画是app设计里面最重要的元素之一，这些动画能够显著提升用户体验。下面会讲解Android系统是如何处理UI组件的更新操作的。</p>

<p>通常来说，Android需要把XML布局文件转换成GPU能够识别并绘制的对象。这个操作是在<strong>DisplayList</strong>的帮助下完成的。DisplayList持有所有将要交给GPU绘制到屏幕上的数据信息。</p>

<p>在某个View第一次需要被渲染时，DisplayList会因此而被创建，当这个View要显示到屏幕上时，我们会执行GPU的绘制指令来进行渲染。如果你在后续有执行类似移动这个View的位置等操作而需要再次渲染这个View时，我们就仅仅需要额外操作一次渲染指令就够了。然而如果你修改了View中的某些可见组件，那么之前的DisplayList就无法继续使用了，我们需要回头重新创建一个DisplayList并且重新执行渲染指令并更新到屏幕上。</p>

<p>需要注意的是：任何时候View中的绘制内容发生变化时，都会重新执行创建DisplayList，渲染DisplayList，更新到屏幕上等一系列操作。这个流程的表现性能取决于你的View的复杂程度，View的状态变化以及渲染管道的执行性能。举个例子，假设某个Button的大小需要增大到目前的两倍，在增大Button大小之前，需要通过父View重新计算并摆放其他子View的位置。修改View的大小会触发整个HierarcyView的重新计算大小的操作。如果是修改View的位置则会触发HierarchView重新计算其他View的位置。如果布局很复杂，这就会很容易导致严重的性能问题。我们需要尽量减少Overdraw。</p>

<p><img src="/images/layout_three_steps.png" alt="" /></p>

<p>我们可以通过前面介绍的Monitor GPU Rendering来查看渲染的表现性能如何，另外也可以通过开发者选项里面的Show GPU view updates来查看视图更新的操作，最后我们还可以通过HierarchyViewer这个工具来查看布局，使得布局尽量扁平化，移除非必需的UI组件，这些操作能够减少Measure，Layout的计算时间。</p>

<h2>7)Overdraw, Cliprect, QuickReject</h2>

<p>引起性能问题的一个很重要的方面是因为过多复杂的绘制操作。我们可以通过工具来检测并修复标准UI组件的Overdraw问题，但是针对高度自定义的UI组件则显得有些力不从心。</p>

<p>有一个窍门是我们可以通过执行几个APIs方法来显著提升绘制操作的性能。前面有提到过，非可见的UI组件进行绘制更新会导致Overdraw。例如Nav Drawer从前置可见的Activity滑出之后，如果还继续绘制那些在Nav Drawer里面不可见的UI组件，这就导致了Overdraw。为了解决这个问题，Android系统会通过避免绘制那些完全不可见的组件来尽量减少Overdraw。那些Nav Drawer里面不可见的View就不会被执行浪费资源。</p>

<p><img src="/images/overdraw_invisible.png" alt="" /></p>

<p>但是不幸的是，对于那些过于复杂的自定义的View(重写了onDraw方法)，Android系统无法检测具体在onDraw里面会执行什么操作，系统无法监控并自动优化，也就无法避免Overdraw了。但是我们可以通过<a href="http://developer.android.com/reference/android/graphics/Canvas.html">canvas.clipRect()</a>来帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视。这个API可以很好的帮助那些有多组重叠组件的自定义View来控制显示的区域。同时clipRect方法还可以帮助节约CPU与GPU资源，在clipRect区域之外的绘制指令都不会被执行，那些部分内容在矩形区域内的组件，仍然会得到绘制。</p>

<p><img src="/images/overdraw_reduce_cpu_gpu.png" alt="" /></p>

<p>除了clipRect方法之外，我们还可以使用<a href="http://developer.android.com/reference/android/graphics/Canvas.html">canvas.quickreject()</a>来判断是否没和某个矩形相交，从而跳过那些非矩形区域内的绘制操作。做了那些优化之后，我们可以通过上面介绍的Show GPU Overdraw来查看效果。</p>

<h2>8)Memory Churn and performance</h2>

<p>虽然Android有自动管理内存的机制，但是对内存的不恰当使用仍然容易引起严重的性能问题。在同一帧里面创建过多的对象是件需要特别引起注意的事情。</p>

<p>Android系统里面有一个<strong>Generational Heap Memory</strong>的模型，系统会根据内存中不同的内存数据类型分别执行不同的GC操作。例如，最近刚分配的对象会放在Young Generation区域，这个区域的对象通常都是会快速被创建并且很快被销毁回收的，同时这个区域的GC操作速度也是比Old Generation区域的GC操作速度更快的。</p>

<p><img src="/images/memory_mode_generation.png" alt="" /></p>

<p>除了速度差异之外，执行GC操作的时候，所有线程的任何操作都会需要暂停，等待GC操作完成之后，其他操作才能够继续运行。</p>

<p><img src="/images/gc_event_thread_stop.png" alt="" /></p>

<p>通常来说，单个的GC并不会占用太多时间，但是大量不停的GC操作则会显著占用帧间隔时间(16ms)。如果在帧间隔时间里面做了过多的GC操作，那么自然其他类似计算，渲染等操作的可用时间就变得少了。</p>

<p>导致GC频繁执行有两个原因：</p>

<ul>
<li><strong>Memory Churn内存抖动</strong>，内存抖动是因为大量的对象被创建又在短时间内马上被释放。</li>
<li>瞬间产生大量的对象会严重占用Young Generation的内存区域，当达到阀值，剩余空间不够的时候，也会触发GC。即使每次分配的对象占用了很少的内存，但是他们叠加在一起会增加Heap的压力，从而触发更多其他类型的GC。这个操作有可能会影响到帧率，并使得用户感知到性能问题。</li>
</ul>


<p><img src="/images/gc_overtime.png" alt="" /></p>

<p>解决上面的问题有简洁直观方法，如果你在<strong>Memory Monitor</strong>里面查看到短时间发生了多次内存的涨跌，这意味着很有可能发生了内存抖动。</p>

<p><img src="/images/memory_monitor_gc.png" alt="" /></p>

<p>同时我们还可以通过<strong>Allocation Tracker</strong>来查看在短时间内，同一个栈中不断进出的相同对象。这是内存抖动的典型信号之一。</p>

<p>当你大致定位问题之后，接下去的问题修复也就显得相对直接简单了。例如，你需要避免在for循环里面分配对象占用内存，需要尝试把对象的创建移到循环体之外，自定义View中的onDraw方法也需要引起注意，每次屏幕发生绘制以及动画执行过程中，onDraw方法都会被调用到，避免在onDraw方法里面执行复杂的操作，避免创建对象。对于那些无法避免需要创建对象的情况，我们可以考虑对象池模型，通过对象池来解决频繁创建与销毁的问题，但是这里需要注意结束使用之后，需要手动释放对象池中的对象。</p>

<h2>9)Garbage Collection in Android</h2>

<p>JVM的回收机制给开发人员带来很大的好处，不用时刻处理对象的分配与回收，可以更加专注于更加高级的代码实现。相比起Java，C与C++等语言具备更高的执行效率，他们需要开发人员自己关注对象的分配与回收，但是在一个庞大的系统当中，还是免不了经常发生部分对象忘记回收的情况，这就是内存泄漏。</p>

<p>原始JVM中的GC机制在Android中得到了很大程度上的优化。Android里面是一个三级Generation的内存模型，最近分配的对象会存放在Young Generation区域，当这个对象在这个区域停留的时间达到一定程度，它会被移动到Old Generation，最后到Permanent Generation区域。</p>

<p><img src="/images/android_memory_gc_mode.png" alt="" /></p>

<p>每一个级别的内存区域都有固定的大小，此后不断有新的对象被分配到此区域，当这些对象总的大小快达到这一级别内存区域的阀值时，会触发GC的操作，以便腾出空间来存放其他新的对象。</p>

<p><img src="/images/gc_threshold.png" alt="" /></p>

<p>前面提到过每次GC发生的时候，所有的线程都是暂停状态的。GC所占用的时间和它是哪一个Generation也有关系，Young Generation的每次GC操作时间是最短的，Old Generation其次，Permanent Generation最长。执行时间的长短也和当前Generation中的对象数量有关，遍历查找20000个对象比起遍历50个对象自然是要慢很多的。</p>

<p>虽然Google的工程师在尽量缩短每次GC所花费的时间，但是特别注意GC引起的性能问题还是很有必要。如果不小心在最小的for循环单元里面执行了创建对象的操作，这将很容易引起GC并导致性能问题。通过Memory Monitor我们可以查看到内存的占用情况，每一次瞬间的内存降低都是因为此时发生了GC操作，如果在短时间内发生大量的内存上涨与降低的事件，这说明很有可能这里有性能问题。我们还可以通过<strong>Heap and Allocation Tracker</strong>工具来查看此时内存中分配的到底有哪些对象。</p>

<h2>10)Performance Cost of Memory Leaks</h2>

<p>虽然Java有自动回收的机制，可是这不意味着Java中不存在内存泄漏的问题，而内存泄漏会很容易导致严重的性能问题。</p>

<p>内存泄漏指的是那些程序不再使用的对象无法被GC识别，这样就导致这个对象一直留在内存当中，占用了宝贵的内存空间。显然，这还使得每级Generation的内存区域可用空间变小，GC就会更容易被触发，从而引起性能问题。</p>

<p>寻找内存泄漏并修复这个漏洞是件很棘手的事情，你需要对执行的代码很熟悉，清楚的知道在特定环境下是如何运行的，然后仔细排查。例如，你想知道程序中的某个activity退出的时候，它之前所占用的内存是否有完整的释放干净了？首先你需要在activity处于前台的时候使用Heap Tool获取一份当前状态的内存快照，然后你需要创建一个几乎不这么占用内存的空白activity用来给前一个Activity进行跳转，其次在跳转到这个空白的activity的时候主动调用System.gc()方法来确保触发一个GC操作。最后，如果前面这个activity的内存都有全部正确释放，那么在空白activity被启动之后的内存快照中应该不会有前面那个activity中的任何对象了。</p>

<p><img src="/images/memory_leak_profile_method.png" alt="" /></p>

<p>如果你发现在空白activity的内存快照中有一些可疑的没有被释放的对象存在，那么接下去就应该使用<strong>Alocation Track Tool</strong>来仔细查找具体的可疑对象。我们可以从空白activity开始监听，启动到观察activity，然后再回到空白activity结束监听。这样操作以后，我们可以仔细观察那些对象，找出内存泄漏的真凶。</p>

<p><img src="/images/memory_leak_track_method.png" alt="" /></p>

<h2>11)Memory Performance</h2>

<p>通常来说，Android对GC做了大量的优化操作，虽然执行GC操作的时候会暂停其他任务，可是大多数情况下，GC操作还是相对很安静并且高效的。但是如果我们对内存的使用不恰当，导致GC频繁执行，这样就会引起不小的性能问题。</p>

<p>为了寻找内存的性能问题，Android Studio提供了工具来帮助开发者。</p>

<ul>
<li><strong>Memory Monitor：</strong>查看整个app所占用的内存，以及发生GC的时刻，短时间内发生大量的GC操作是一个危险的信号。</li>
<li><strong>Allocation Tracker：</strong>使用此工具来追踪内存的分配，前面有提到过。</li>
<li><strong>Heap Tool：</strong>查看当前内存快照，便于对比分析哪些对象有可能是泄漏了的，请参考前面的Case。</li>
</ul>


<h2>12)Tool - Memory Monitor</h2>

<p>Android Studio中的Memory Monitor可以很好的帮助我们查看程序的内存使用情况。</p>

<p><img src="/images/memory_monitor_overview.png" alt="" /></p>

<p><img src="/images/memory_monitor_free_allocation.png" alt="" /></p>

<p><img src="/images/memory_monitor_gc_event.png" alt="" /></p>

<h2>13)Battery Performance</h2>

<p>电量其实是目前手持设备最宝贵的资源之一，大多数设备都需要不断的充电来维持继续使用。不幸的是，对于开发者来说，电量优化是他们最后才会考虑的的事情。但是可以确定的是，千万不能让你的应用成为消耗电量的大户。</p>

<p>Purdue University研究了最受欢迎的一些应用的电量消耗，平均只有30%左右的电量是被程序最核心的方法例如绘制图片，摆放布局等等所使用掉的，剩下的70%左右的电量是被上报数据，检查位置信息，定时检索后台广告信息所使用掉的。如何平衡这两者的电量消耗，就显得非常重要了。</p>

<p>有下面一些措施能够显著减少电量的消耗：</p>

<ul>
<li>我们应该尽量减少唤醒屏幕的次数与持续的时间，使用WakeLock来处理唤醒的问题，能够正确执行唤醒操作并根据设定及时关闭操作进入睡眠状态。</li>
<li>某些非必须马上执行的操作，例如上传歌曲，图片处理等，可以等到设备处于充电状态或者电量充足的时候才进行。</li>
<li>触发网络请求的操作，每次都会保持无线信号持续一段时间，我们可以把零散的网络请求打包进行一次操作，避免过多的无线信号引起的电量消耗。关于网络请求引起无线信号的电量消耗，还可以参考这里<a href="http://hukai.me/android-training-course-in-chinese/connectivity/efficient-downloads/efficient-network-access.html">http://hukai.me/android-training-course-in-chinese/connectivity/efficient-downloads/efficient-network-access.html</a></li>
</ul>


<p>我们可以通过手机设置选项找到对应App的电量消耗统计数据。我们还可以通过<strong>Battery Historian Tool</strong>来查看详细的电量消耗。</p>

<p><img src="/images/battery_usages_settings.png" alt="" /></p>

<p>如果发现我们的App有电量消耗过多的问题，我们可以使用JobScheduler API来对一些任务进行定时处理，例如我们可以把那些任务重的操作等到手机处于充电状态，或者是连接到WiFi的时候来处理。
关于JobScheduler的更多知识可以参考<a href="http://hukai.me/android-training-course-in-chinese/background-jobs/scheduling/index.html">http://hukai.me/android-training-course-in-chinese/background-jobs/scheduling/index.html</a></p>

<h2>14)Understanding Battery Drain on Android</h2>

<p>电量消耗的计算与统计是一件麻烦而且矛盾的事情，记录电量消耗本身也是一个费电量的事情。唯一可行的方案是使用第三方监测电量的设备，这样才能够获取到真实的电量消耗。</p>

<p>当设备处于待机状态时消耗的电量是极少的，以N5为例，打开飞行模式，可以待机接近1个月。可是点亮屏幕，硬件各个模块就需要开始工作，这会需要消耗很多电量。</p>

<p>使用WakeLock或者JobScheduler唤醒设备处理定时的任务之后，一定要及时让设备回到初始状态。每次唤醒无线信号进行数据传递，都会消耗很多电量，它比WiFi等操作更加的耗电，详情请关注<a href="http://hukai.me/android-training-course-in-chinese/connectivity/efficient-downloads/efficient-network-access.html">http://hukai.me/android-training-course-in-chinese/connectivity/efficient-downloads/efficient-network-access.html</a></p>

<p><img src="/images/battery_drain_radio.png" alt="" /></p>

<p>修复电量的消耗是另外一个很大的课题，这里就不展开继续了。</p>

<h2>15)Battery Drain and WakeLocks</h2>

<p>高效的保留更多的电量与不断促使用户使用你的App会消耗电量，这是矛盾的选择题。不过我们可以使用一些更好的办法来平衡两者。</p>

<p>假设你的手机里面装了大量的社交类应用，即使手机处于待机状态，也会经常被这些应用唤醒用来检查同步新的数据信息。Android会不断关闭各种硬件来延长手机的待机时间，首先屏幕会逐渐变暗直至关闭，然后CPU进入睡眠，这一切操作都是为了节约宝贵的电量资源。但是即使在这种睡眠状态下，大多数应用还是会尝试进行工作，他们将不断的唤醒手机。一个最简单的唤醒手机的方法是使用PowerManager.WakeLock的API来保持CPU工作并防止屏幕变暗关闭。这使得手机可以被唤醒，执行工作，然后回到睡眠状态。知道如何获取WakeLock是简单的，可是及时释放WakeLock也是非常重要的，不恰当的使用WakeLock会导致严重错误。例如网络请求的数据返回时间不确定，导致本来只需要10s的事情一直等待了1个小时，这样会使得电量白白浪费了。这也是为何使用带超时参数的wakelock.acquice()方法是很关键的。但是仅仅设置超时并不足够解决问题，例如设置多长的超时比较合适？什么时候进行重试等等？</p>

<p>解决上面的问题，正确的方式可能是使用非精准定时器。通常情况下，我们会设定一个时间进行某个操作，但是动态修改这个时间也许会更好。例如，如果有另外一个程序需要比你设定的时间晚5分钟唤醒，最好能够等到那个时候，两个任务捆绑一起同时进行，这就是非精确定时器的核心工作原理。我们可以定制计划的任务，可是系统如果检测到一个更好的时间，它可以推迟你的任务，以节省电量消耗。</p>

<p><img src="/images/alarmmanager_inexact_wakelock.png" alt="" /></p>

<p>这正是JobScheduler API所做的事情。它会根据当前的情况与任务，组合出理想的唤醒时间，例如等到正在充电或者连接到WiFi的时候，或者集中任务一起执行。我们可以通过这个API实现很多免费的调度算法。</p>

<p>从Android 5.0开始发布了Battery History Tool，它可以查看程序被唤醒的频率，又谁唤醒的，持续了多长的时间，这些信息都可以获取到。</p>

<p>请关注程序的电量消耗，用户可以通过手机的设置选项观察到那些耗电量大户，并可能决定卸载他们。所以尽量减少程序的电量消耗是非常有必要的。</p>
]]></content>
  </entry>
  
</feed>
