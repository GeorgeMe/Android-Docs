<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android:Training:Performance | 四方城]]></title>
  <link href="http://kesenhoo.github.com/blog/categories/android-training-performance/atom.xml" rel="self"/>
  <link href="http://kesenhoo.github.com/"/>
  <updated>2013-09-01T17:24:00+08:00</updated>
  <id>http://kesenhoo.github.com/</id>
  <author>
    <name><![CDATA[Kesen Hoo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android Training Performance - 性能优化小技巧]]></title>
    <link href="http://kesenhoo.github.com/blog/2013/04/06/android-training-performance-tips/"/>
    <updated>2013-04-06T18:27:00+08:00</updated>
    <id>http://kesenhoo.github.com/blog/2013/04/06/android-training-performance-tips</id>
    <content type="html"><![CDATA[<h2>Performance Tips</h2>

<p><img src="/images/articles/performance_improve.jpg"></p>

<p>这篇文章主要是介绍了一些小细节的优化技巧，当这些小技巧综合使用起来的时候，对于整个App的性能提升还是有作用的，只是不能较大幅度的提升性能而已。选择合适的算法与数据结构才应该是你首要考虑的因素，在这篇文章中不会涉及这方面。你应该使用这篇文章中的小技巧作为平时写代码的习惯，这样能够提升代码的效率。</p>

<!-- more -->


<p>通常来说，高效的代码需要满足下面两个规则：</p>

<ul>
<li>不要做冗余的动作</li>
<li>如果能避免，尽量不要分配内存</li>
</ul>


<p>代码的执行效果会受到设备CPU,设备内存,系统版本等诸多因素的影响。为了确保代码能够在不同设备上都运行良好，需要最大化代码的效率。</p>

<h3>避免创建不必要的对象</h3>

<p>虽然GC可以回收不用的对象，可是为这些对象分配内存，并回收它们同样是需要耗费资源的。<br/>
因此请尽量避免创建不必要的对象，有下面一些例子来说明这个问题：</p>

<ul>
<li>如果你需要返回一个String对象，并且你知道它最终会需要连接到一个StringBuffer，请修改你的实现方式，避免直接进行连接操作，应该采用创建一个临时对象来做这个操作.</li>
<li>当从输入的数据集中抽取出Strings的时候，尝试返回原数据的substring对象，而不是创建一个重复的对象。</li>
</ul>


<p>一个稍微激进点的做法是把所有多维的数据分解成1维的数组:</p>

<ul>
<li>一组int数据要比一组Integer对象要好很多。可以得知，两组1维数组要比一个2维数组更加的有效率。同样的，这个道理可以推广至其他原始数据类型。</li>
<li>如果你需要实现一个数组用来存放(Foo,Bar)的对象，尝试分解为Foo[]与Bar[]要比(Foo,Bar)好很多。(当然，为了某些好的API的设计，可以适当做一些妥协。但是在自己的代码内部，你应该多多使用分解后的容易。</li>
</ul>


<p>通常来说，需要避免创建更多的对象。更少的对象意味者更少的GC动作，GC会对用户体验有比较直接的影响。</p>

<h3>选择Static而不是Virtual</h3>

<p>如果你不需要访问一个对象的值域,请保证这个方法是static类型的,这样方法调用将快15%-20%。这是一个好的习惯，因为你可以从方法声明中得知调用无法改变这个对象的状态。</p>

<h3>常量声明为Static Final</h3>

<p>先看下面这种声明的方式
<code>java
static int intVal = 42;
static String strVal = "Hello, world!";
</code>
编译器会使用<clinit>方法来初始化上面的值，之后访问的时候会需要先到它那里查找，然后才返回数据。我们可以使用static final来提升性能：
<code>java
static final int intVal = 42;
static final String strVal = "Hello, world!";
</code>
这时再也不需要上面的那个方法来做多余的查找动作了。<br/>
<strong> 所以，请尽可能的为常量声明为static final类型的。</strong></p>

<h3>避免内部的Getters/Setters</h3>

<p>像C++等native language,通常使用getters(i = getCount())而不是直接访问变量(i = mCount).这是编写C++的一种优秀习惯，而且通常也被其他面向对象的语言所采用，例如C#与Java，因为编译器通常会做inline访问，而且你需要限制或者调试变量，你可以在任何时候在getter/setter里面添加代码。<br/>
然而，在Android上，这是一个糟糕的写法。Virtual method的调用比起直接访问变量要耗费更多。那么合理的做法是：在面向对象的设计当中应该使用getter/setter，但是在类的内部你应该直接访问变量.<br/>
没有JIT(Just In Time Compiler)时，直接访问变量的速度是调用getter的3倍。有JIT时,直接访问变量的速度是通过getter访问的7倍。<br/>
请注意，如果你使用<a href="http://developer.android.com/tools/help/proguard.html">ProGuard</a>, 你可以获得同样的效果，因为ProGuard可以为你inline accessors.</p>

<h3>使用增强的For循环</h3>

<p>请比较下面三种循环的方法：</p>

<p>```java
static class Foo {</p>

<pre><code>int mSplat;
</code></pre>

<p>}</p>

<p>Foo[] mArray = ...</p>

<p>public void zero() {</p>

<pre><code>int sum = 0;
for (int i = 0; i &lt; mArray.length; ++i) {
    sum += mArray[i].mSplat;
}
</code></pre>

<p>}</p>

<p>public void one() {</p>

<pre><code>int sum = 0;
Foo[] localArray = mArray;
int len = localArray.length;

for (int i = 0; i &lt; len; ++i) {
    sum += localArray[i].mSplat;
}
</code></pre>

<p>}</p>

<p>public void two() {</p>

<pre><code>int sum = 0;
for (Foo a : mArray) {
    sum += a.mSplat;
}
</code></pre>

<p>}
```</p>

<ul>
<li>zero()是最慢的，因为JIT没有办法对它进行优化。</li>
<li>one()稍微快些。</li>
<li>two() 在没有做JIT时是最快的，可是如果经过JIT之后，与方法one()是差不多一样快的。它使用了增强的循环方法for-each。</li>
</ul>


<p>所以请尽量使用for-each的方法，但是对于ArrayList，请使用方法one()。</p>

<h3>使用包级访问而不是内部类的私有访问</h3>

<p>参考下面一段代码</p>

<p>```java
public class Foo {</p>

<pre><code>private class Inner {
    void stuff() {
        Foo.this.doStuff(Foo.this.mValue);
    }
}

private int mValue;

public void run() {
    Inner in = new Inner();
    mValue = 27;
    in.stuff();
}

private void doStuff(int value) {
    System.out.println("Value is " + value);
}
</code></pre>

<p>}
```
Foo$Inner里面有访问外部类的一个变量。这样的做法会给系统造成额外的麻烦，请尽量避免。</p>

<h3>避免使用float类型</h3>

<p>Android系统中float类型的数据存取速度是int类型的一半，尽量优先采用int类型。</p>

<h3>使用库函数</h3>

<p>尽量使用System.arraycopy()等一些封装好的库函数，它的效率是手动编写copy实现的9倍多。</p>

<p><strong> Tip: Also see Josh Bloch's Effective Java, item 47. </strong></p>

<h3>谨慎使用native函数</h3>

<p>当你需要把已经存在的native code迁移到Android，请谨慎使用JNI。如果你要使用JNI,请学习<a href="http://developer.android.com/guide/practices/jni.html">JNI Tips</a></p>

<h3>关于性能的误区</h3>

<p>在没有做JIT之前，使用一种确切的数据类型确实要比抽象的数据类型速度要更有效率。(例如，使用HashMap要比Map效率更高。) 有误传效率要高一倍，实际上只是6%左右。而且，在JIT之后，他们直接并没有大多差异。</p>

<h3>关于测量</h3>

<p>上面文档中出现的数据是Android的实际运行效果。我们可以用<a href="http://developer.android.com/tools/debugging/debugging-tracing.html">Traceview</a> 来测量，但是测量的数据是没有经过JIT优化的，所以实际的效果应该是要比测量的数据稍微好些。</p>

<p>关于如何测量与调试，还可以参考下面两篇文章：</p>

<ul>
<li><a href="http://developer.android.com/tools/debugging/debugging-tracing.html">Profiling with Traceview and dmtracedump</a></li>
<li><a href="http://developer.android.com/tools/debugging/systrace.html">Analysing Display and Performance with Systrace</a></li>
</ul>


<hr />

<p><strong>文章学习自http://developer.android.com/guide/components/processes-and-threads.html</strong><br/>
<strong>转载请注明出自<a href="http:://kesenhoo.github.com">http://kesenhoo.github.com</a>，谢谢</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Training Performance - 提升布局文件的性能(Lesson 4 - 使用ViewHolder来提升ListView的性能)]]></title>
    <link href="http://kesenhoo.github.com/blog/2012/03/21/android-training-performance-improve-layouts-lesson-4/"/>
    <updated>2012-03-21T21:20:00+08:00</updated>
    <id>http://kesenhoo.github.com/blog/2012/03/21/android-training-performance-improve-layouts-lesson-4</id>
    <content type="html"><![CDATA[<h2>Making ListView Scrolling Smooth</h2>

<p>使得滚动ListView平滑的关键在与保持APP的UI thread与复杂的操作隔离。确保另起一个Thread来处理Disk IO，network access或者SQL access.
为了测试AP的状态，可以enable <a href="http://developer.android.com/reference/android/os/StrictMode.html">StrictMode</a>.(Android ICS 4.0上已经默认开启了StrickMode)</p>

<!-- More -->


<h2>1)Use a Background Thread</h2>

<p>使用后台线程，这样可以使得UI线程可以专注于描绘UI。大多数时候，AsycnTask实现了一种简单把需要做的事情与main thread隔离的方法。下面是一个例子：
```java
// Using an AsyncTask to load the slow images in a background thread<br/>
new AsyncTask&lt;ViewHolder, Void, Bitmap>() {</p>

<pre><code>private ViewHolder v;  

@Override  
protected Bitmap doInBackground(ViewHolder... params) {  
    v = params[0];  
    return mFakeImageLoader.getImage();  
}  

@Override  
protected void onPostExecute(Bitmap result) {  
    super.onPostExecute(result);  
    if (v.position == position) {  
        // If this item hasn't been recycled already, hide the  
        // progress and set and show the image  
        v.progress.setVisibility(View.GONE);  
        v.icon.setVisibility(View.VISIBLE);  
        v.icon.setImageBitmap(result);  
    }  
}  
</code></pre>

<p>}.execute(holder);
```
从Android 3.0开始，对于AsyncTask有个额外的特色：在多核处理器的情况下，我们可以使用<a href="http://developer.android.com/reference/android/os/AsyncTask.html#executeOnExecutor(java.util.concurrent.Executor,%20Params...">executeOnExecutor()</a>) 来替代execute()，这样系统会根据当前设备的内核数量同时进行多个任务。</p>

<h2>2)Hold View Objects in a View Holder</h2>

<p>你的程序在滚动ListView的时候也许会重复频繁的call findViewById()，这样会降低性能。尽管Adapter会因为View的循环机制返回一个创建好的View。你仍然需要查找到这些组件并更新它，避免这样的重复，我们可以使用ViewHolder的设计模式。</p>

<p>A ViewHolder对象存放每一个View组件于Layout的tag属性中，因此我们可以立即访问tag中的组件从而避免重复call findViewById()。下面是定义了一个ViewHolder的例子：
<code>java
static class ViewHolder {  
  TextView text;  
  TextView timestamp;  
  ImageView icon;  
  ProgressBar progress;  
  int position;  
}
</code><br/>
这样之后，我们可以填充这个ViewHolder，并且保存到tag field.
<code>java
ViewHolder holder = new ViewHolder();  
holder.icon = (ImageView) convertView.findViewById(R.id.listitem_image);  
holder.text = (TextView) convertView.findViewById(R.id.listitem_text);  
holder.timestamp = (TextView) convertView.findViewById(R.id.listitem_timestamp);  
holder.progress = (ProgressBar) convertView.findViewById(R.id.progress_spinner);  
convertView.setTag(holder);  
</code>
那么我们就可以直接访问里面的数据了，省去了重复查询，提升了性能。</p>

<hr />

<p><strong>文章学习自<a href="http://developer.android.com/training/improving-layouts/smooth-scrolling.html">http://developer.android.com/training/improving-layouts/smooth-scrolling.html
</a></strong>
<strong>转载请注明出自<a href="http:://kesenhoo.github.com">http://kesenhoo.github.com</a>，谢谢</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Training Performance - 提升布局文件的性能(Lesson 3 - 使用viewStub按需载入视图)]]></title>
    <link href="http://kesenhoo.github.com/blog/2012/03/21/android-training-performance-improve-layouts-lesson-3/"/>
    <updated>2012-03-21T18:47:00+08:00</updated>
    <id>http://kesenhoo.github.com/blog/2012/03/21/android-training-performance-improve-layouts-lesson-3</id>
    <content type="html"><![CDATA[<h2>Loading Views On Demand</h2>

<p>某些时候，我们需要一些很复杂的视图却仅仅很少用到。如果我们在它仅仅需要的时候再载入，这样可以减少内存的使用并且给用户带来流畅的体验。</p>

<h2>1)Define a ViewStub</h2>

<p><a href="http://developer.android.com/reference/android/view/ViewStub.html">ViewStub</a>是一个轻量级的view，没有占有空间，没有花费draw的资源，也没有参与在任何一个layout的计算与绘制里面。</p>

<p>创建它仅需要很少的系统资源，而且存留在View的层级也是个比较不花费资源的动作。</p>

<!-- More -->


<p>每一个ViewStub简单的包含一个<code>android:layout</code>的属性来指定待创建的布局文件。</p>

<p>下面是一个包含Progress bar的ViewStub例子，这对于overlay来说是透明的，progress bar仅仅会在需要导入的时候才会可见。
```xml
&lt;ViewStub</p>

<pre><code>android:id="@+id/stub_import"  
android:inflatedId="@+id/panel_import"  
android:layout="@layout/progress_overlay"  
android:layout_width="fill_parent"  
android:layout_height="wrap_content"  
android:layout_gravity="bottom" /&gt;  
</code></pre>

<p>```</p>

<h2>2)Load the ViewStub Layout</h2>

<p>当你想要载入在ViewStub中定义的布局的时候，可以calling setVisibility(View.VISIBLE) 或者是调用 inflate().
```java
 ((ViewStub) findViewById(R.id.stub_import)).setVisibility(View.VISIBLE);</p>

<p>// or
View importPanel = ((ViewStub) findViewById(R.id.stub_import)).inflate();
```
一旦被设置可见或者被创建，这个ViewStub组件则从View层级中消失，它被创建出来的布局所替代，而且这个布局的ID就是ViewStub里面用android:inflatedId属性所定义的。（用来定义这个ViewStub的ID的属性andoid:id直到被可见才是有效的）。</p>

<p><strong>Note:</strong>ViewStub的一个缺陷是目前并不支持创建包含有<merge>标签的布局文件。更多ViewStub的信息请看：http://developer.android.com/resources/articles/layout-tricks-stubs.html</p>

<hr />

<p><strong>文章学习自<a href="http://developer.android.com/training/improving-layouts/loading-ondemand.html">http://developer.android.com/training/improving-layouts/loading-ondemand.html
</a></strong>
<strong>转载请注明出自<a href="http:://kesenhoo.github.com">http://kesenhoo.github.com</a>，谢谢</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Training Performance - 提升布局文件的性能(Lesson 2 - 使用include标签重用Layout)]]></title>
    <link href="http://kesenhoo.github.com/blog/2012/03/21/android-training-performance-improve-layouts-lesson-2/"/>
    <updated>2012-03-21T18:06:00+08:00</updated>
    <id>http://kesenhoo.github.com/blog/2012/03/21/android-training-performance-improve-layouts-lesson-2</id>
    <content type="html"><![CDATA[<h2>Re-using Layouts with <include/></h2>

<p>尽管Android提供了很多种小的组件可以重用，我们还需要自定义一些稍微复杂一点的小组件进行重用。我们可以使用<code>&lt;include/&gt;</code> 与 <code>&lt;merge/&gt;</code> 标签来对当前的layout嵌入一些其他的layout.</p>

<p>在创建一个稍微复杂一点的layout时，重用layout是个很给力的方法。比如我们需要一个YES/NO的控制栏，包含文字提示的Progress bar。像这种的布局会在很多地方需要重用到.</p>

<!-- More -->


<h2>1)Create a Re-usable Layout</h2>

<p>如果你已经知道哪些组件是会重用的，我们可以创建一个XML并且定义这个layout。例如：下面定义了一个需要在每个Activity都需要显示的titlebar.xml
```xml
&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"</p>

<pre><code>android:layout_width=”match_parent”  
android:layout_height="wrap_content"  
android:background="@color/titlebar_bg"&gt;  

&lt;ImageView android:layout_width="wrap_content"  
           android:layout_height="wrap_content"   
           android:src="@drawable/gafricalogo" /&gt;  
</code></pre>

<p></FrameLayout>
```</p>

<h2>2)Use the <include> Tag</h2>

<p>下面示例了一个包含了titlebar控件的布局：
```xml
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"</p>

<pre><code>android:orientation="vertical"   
android:layout_width=”match_parent”  
android:layout_height=”match_parent”  
android:background="@color/app_bg"  
android:gravity="center_horizontal"&gt;  

&lt;include layout="@layout/titlebar"/&gt;  

&lt;TextView android:layout_width=”match_parent”  
          android:layout_height="wrap_content"  
          android:text="@string/hello"  
          android:padding="10dp" /&gt;  

...  
</code></pre>

<p></LinearLayout>
<code>  
我们可以重写任何include里面的属性，例如：
</code>xml
&lt;include android:id=”@+id/news_title”</p>

<pre><code>     android:layout_width=”match_parent”  
     android:layout_height=”match_parent”  
     layout=”@layout/title”/&gt;  
</code></pre>

<p>```</p>

<h2>3)Use the <merge> Tag</h2>

<p>某些时候，自定义可重用的布局包含了过多的层级标签，比如我们需要在LinearLayout里面嵌入一个重用的组件，而恰恰这个自定义的可重用的组件根节点也是LinearLayout，这样就多了一层没有用的嵌套，无疑这样只会拖慢程序速度。而这个时候如果我们使用merge根标签就可以避免那样的问题。例如：
```xml
<merge xmlns:android="http://schemas.android.com/apk/res/android"></p>

<pre><code>&lt;Button  
    android:layout_width="fill_parent"   
    android:layout_height="wrap_content"  
    android:text="@string/add"/&gt;  

&lt;Button  
    android:layout_width="fill_parent"   
    android:layout_height="wrap_content"  
    android:text="@string/delete"/&gt;  
</code></pre>

<p></merge><br/>
<code>``
这样的话，使用</code><include>`包含上面的布局的时候，系统会自动忽略merge层级，而把两个button直接放置与include平级。</p>

<hr />

<p><strong>文章学习自<a href="http://developer.android.com/training/improving-layouts/reusing-layouts.html">http://developer.android.com/training/improving-layouts/reusing-layouts.html
</a></strong>
<strong>转载请注明出自<a href="http:://kesenhoo.github.com">http://kesenhoo.github.com</a>，谢谢</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Training Performance - 提升布局文件的性能(Lesson 1 - 优化布局的层级)]]></title>
    <link href="http://kesenhoo.github.com/blog/2012/03/21/android-training-performance-improve-layouts-lesson-1/"/>
    <updated>2012-03-21T17:14:00+08:00</updated>
    <id>http://kesenhoo.github.com/blog/2012/03/21/android-training-performance-improve-layouts-lesson-1</id>
    <content type="html"><![CDATA[<h2>Optimizing Layout Hierarchies</h2>

<p>Layout是Android程序影响用户体验最关键的一部分。如果布局文件不好会使得程序比较卡。SDK里面包含了一些工具用来帮助我们发现布局文件的性能问题</p>

<p>使用基本的Layout结构是最有效的。但是，每一个添加到系统的组件都需要初始化，进行布局，绘制的过程。比如，使用在LinearLayout里面使用子组件会导致一个过于deep的层级结构。而且内嵌使用包含layout_weight属性的LinearLayout会在绘制时花费昂贵的系统资源，因为每一个子组件都需要被测量两次。在使用ListView与GridView的时候，这个问题显的尤其重要，因为子组件会重复被创建</p>

<p>这一课我们会学习使用Hierarchy Viewer and Lint 来检查并最优化布局文件。</p>

<!-- More -->


<h2>1)Inspect Your Layout</h2>

<p>Android SDK里面包含了一个叫做<a href="http://developer.android.com/tools/help/hierarchy-viewer.html">Hierarchy Viewer</a>的工具，在程序运行的时候分析布局文件，从而找到性能瓶颈</p>

<p>连接上设备，打开Hierarchy Viewer(定位到tools/目录下，直接执行hierarchyviewer的命令，选定需要查看的Process，再点击Load View Hierarchy会显示出当前界面的布局Tree。在每个模块的Traffic light上有三个灯，分别代表了Measure, Layout and Draw三个步骤的性能。</p>

<p><img src="/images/articles/layout-listitem.png" title="Figure 1. ListView每个Item的常见布局." alt="layout-listitem.png" /></p>

<p><img src="/images/articles/hierarchy-linearlayout.png" title="Figure 2. 上面显示了对应与图片1的布局层级信息." alt="hierarchy-linearlayout.png" /></p>

<p>可以看到中间LinearLayout的Measure的灯是红色的，这就是因为上面说到的：使用内嵌layout_weight的属性的LinearLayout会导致测量时花费了双倍的时间。</p>

<p><img src="/images/articles/hierarchy-layouttimes.png" title="Figure 3. 点击某个模块会显示具体每个步骤所花费的时间。" alt="hierarchy-layouttimes.png" /></p>

<h2>2)Revise Your Layout</h2>

<p>使得Layout宽而浅，而不是窄而深（在Hierarchy Viewer的Tree视图里面体现）</p>

<p>针对上面的布局我们可以使用RelativeLayout来替代LinearLayout，从而实现shallow and wide.</p>

<p><img src="/images/articles/hierarchy-relativelayout.png" title="Figure 4. 改用RelativeLayout来实现图片1的布局。" alt="hierarchy-relativelayout.png" /></p>

<p>可以看到这是一个小的优化，可是这带来的效果是明显的，因为在ListView里面会出现很多这样的布局。
导致前面的case会出现花费时间比较多的愿意是使用了layout_weight在LinearLayout。我们需要仔细评估到底是否需要使用那样的布局，尽量避免使用layout_weight。</p>

<h2>3)Use Lint</h2>

<p><a href="http://tools.android.com/tips/lint">Lint</a>是一款在ADT 16才出现用来替代layoutopt的新型工具，具有更强大的功能。</p>

<p>Lint的会提示的一些建议规则如下：</p>

<ul>
<li>使用compound drawables - 一个包含了ImageView与TextView的LinearLayout可以被当作一个compound drawable来处理。</li>
<li>使用merge根框架 - 如果FramLayout仅仅是一个纯粹的（没有设置背景，间距等）布局根元素，我们可以使用merge标签来当作根标签。</li>
<li>无用的分支 - 如果一个layout并没有任何子组件，那么可以被移除，这样可以提高效率。</li>
<li>无用的父控件 - 如果一个layout只有子控件，没有兄弟控件，并且不是一个ScrollView或者根节点，而且没有设置背景，那么我们可以移除这个父控件，直接把子控件提升为父控件】</li>
<li>深层次的layout - 尽量减少内嵌的层级，考虑使用更多平级的组件 RelativeLayout or GridLayout来提升布局性能，默认最大的深度是10</li>
</ul>


<p><img src="/images/articles/lint_icon.png" alt="lint_icon.png" /></p>

<p>Eclipse会自动运行Lint的工具，并给出相应的提醒，不管是在导出APK，编辑，保存XML还是在使用layout编辑器的时候。如果想驱动一次运行，请参看上面的图标，点击运行。如果没有安装ADT 16,需要在命令行中执行。</p>

<hr />

<p><strong>文章学习自<a href="http://developer.android.com/training/improving-layouts/optimizing-layout.html">http://developer.android.com/training/improving-layouts/optimizing-layout.html</a></strong>
<strong>转载请注明出自<a href="http:://kesenhoo.github.com">http://kesenhoo.github.com</a>，谢谢</strong></p>
]]></content>
  </entry>
  
</feed>
